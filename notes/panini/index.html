<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="&ldquo;The simplest of several competing explanations is likely to be the correct one&rdquo; - Occam&rsquo;s Razor
 Intelligence as compression (Skip to code walkthrough."><meta property="og:title" content="The PƒÅ·πáinian Approach to Compression"><meta property="og:description" content="&ldquo;The simplest of several competing explanations is likely to be the correct one&rdquo; - Occam&rsquo;s Razor
 Intelligence as compression (Skip to code walkthrough."><meta property="og:type" content="website"><meta property="og:image" content="https://sibeshkar.github.io/icon.png"><meta property="og:url" content="https://sibeshkar.github.io/notes/panini/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="The PƒÅ·πáinian Approach to Compression"><meta name=twitter:description content="&ldquo;The simplest of several competing explanations is likely to be the correct one&rdquo; - Occam&rsquo;s Razor
 Intelligence as compression (Skip to code walkthrough."><meta name=twitter:image content="https://sibeshkar.github.io/icon.png"><meta name=twitter:site content="sibeshkar"><title>The PƒÅ·πáinian Approach to Compression</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://sibeshkar.github.io//icon.png><link href=https://sibeshkar.github.io/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://sibeshkar.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://sibeshkar.github.io/js/darkmode.57cc7b5e8e492d275b93efd99423df30.min.js></script>
<script src=https://sibeshkar.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://sibeshkar.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://sibeshkar.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://sibeshkar.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://sibeshkar.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://sibeshkar.github.io/",fetchData=Promise.all([fetch("https://sibeshkar.github.io/indices/linkIndex.8c5cafe27a13e3618180c8686fb29358.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://sibeshkar.github.io/indices/contentIndex.efceedee9587dff1114458d146812b73.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://sibeshkar.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://sibeshkar.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'‚Äô':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/sibeshkar.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=sibeshkar.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://sibeshkar.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://sibeshkar.github.io/>üëæ skar</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>The PƒÅ·πáinian Approach to Compression</h1><p class=meta>Last updated
Mar 4, 2025
<a href=https://github.com/sibeshkar/notes/panini.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#intelligence-as-compression>Intelligence as compression</a></li><li><a href=#pƒÅ·πáinis-razor>PƒÅ·πáini&rsquo;s Razor</a></li><li><a href=#the-building-blocks>The Building Blocks</a></li><li><a href=#approach-1-naive-grammar---simple-memorization>Approach 1: Naive Grammar - Simple Memorization</a></li><li><a href=#approach-2-pattern-recognition---seeing-relationships>Approach 2: Pattern Recognition - Seeing Relationships</a></li><li><a href=#approach-3-full-abstraction---the-cognitive-leap>Approach 3: Full Abstraction - The Cognitive Leap</a></li><li><a href=#generating-the-sequence>Generating the Sequence</a></li><li><a href=#from-numbers-to-language>From Numbers to Language</a><ol><li><a href=#naive-grammar-store-each-sentence>Naive Grammar (Store Each Sentence):</a></li><li><a href=#pattern-recognition-find-common-structure>Pattern Recognition (Find Common Structure):</a></li><li><a href=#full-abstraction-separate-first-and-second-items>Full Abstraction (Separate First and Second Items):</a></li><li><a href=#the-challenge-of-english-grammar>The Challenge of English Grammar</a></li><li><a href=#a-more-compressible-language>A More Compressible Language</a></li><li><a href=#pƒÅ·πáinis-method-in-action>PƒÅ·πáini&rsquo;s Method in Action</a></li></ol></li><li><a href=#from-numbers-to-pƒÅ·πáini-the-first-computational-grammarian>From Numbers to PƒÅ·πáini: The First Computational Grammarian</a></li><li><a href=#from-ancient-grammar-to-modern-systems--the-case-of-pong>From Ancient Grammar to Modern Systems : The Case of Pong</a></li><li><a href=#the-connection-to-intelligence>The Connection to Intelligence</a></li><li><a href=#references>References</a></li></ol></nav></details></aside><blockquote><p>&ldquo;The simplest of several competing explanations is likely to be the correct one&rdquo; - Occam&rsquo;s Razor</p></blockquote><a href=#intelligence-as-compression><h2 id=intelligence-as-compression><span class=hanchor arialabel=Anchor># </span>Intelligence as compression</h2></a><p>(Skip to
<a href=https://sibeshkar.github.io/notes/panini/#p%C4%81%E1%B9%87inis-razor rel=noopener>code</a> walkthrough.)</p><p>Philosopher John Searle in his famous
<a href=https://plato.stanford.edu/archIves/spr2010/entries/chinese-room/ rel=noopener>Chinese Room argument</a> argues against the possibility of a computer ever being able to think. From outside the closed room it may look like it&rsquo;s conversing in Chinese, but could the machine inside with a memorized table of what Chinese word comes after what be considered to have understood Chinese? The argument intends to show that while suitably programmed computers may appear to converse, they are not capable of developing any understanding of meaning or semantics, even in principle.</p><p>Searle&rsquo;s argument is incorrect. We will soon see how.</p><p>Today&rsquo;s most prominent AIs, large language models (LLMs) like DeepSeek, GPT, or Claude are more sophisticated versions of such shallow &lsquo;generative&rsquo; memory models. They use thousands of tokens of context and the &lsquo;attention&rsquo; mechanism to focus on relevant parts of the input to &lsquo;query&rsquo; a table with. They&rsquo;re not <em>just</em> storing a memorized table of what comes after what, but using compute to extract and store a hiearchy of reusable information in their layers. A result is that the weights of the Llama-65B model occupy around 365GB on disk, down from the 5.6TB it&rsquo;s trained on <strong>(a 14x compression)</strong>[1]. We see that generalization ability and data efficiency are equivalent: generalization comes from squeezing every bit of information out of your datapoints, &lsquo;understanding&rsquo; all correlations and causations, and connecting all the dots. &ldquo;Squeezing every bit of information&rdquo; is meant literally: generalization is the very direct result of compression.</p><p>One could argue against calling this process of parroting statistical regularities &rsquo;true understanding&rsquo;. A 14x (or so) compression ratio would be fairly impressive if nothing better existed. However, these machine learning algorithms are many orders-of-magnitude less data efficient than human beings. Lee Sedol, a top Go player, played around 10,000 games in his lifetime, while DeepMind&rsquo;s bot AlphaGo bot required 30 million games to match him (powered by the energy requirements of a small city). If Sedol had played 30 million games, how skilled would he be? What would a human who has absorbed all of human knowledge look like? What sort of &ldquo;information squeezing&rdquo; is the human brain doing so effectively? I am convinced that the answer to these questions is the key to building general machine intelligence i.e. machines that think, learn, adapt to tasks like (or better than) humans do.</p><p>But it&rsquo;s hard to run this experiment because most humans have seen orders of magnitude less data than any LLM in their lifetimes, and it&rsquo;s hard to manually inspect human priors. Or so I thought, until I attended the lecture series[2] by Dr. Saroja Bhate at Bangalore International Centre, on PƒÅ·πáini (pronounced &ldquo;pah-nee-nee&rdquo;), the ancient Sanskrit grammarian. Over 2300 years ago, before the advent of computers or formal logic, PƒÅ·πáini sat down and methodically reduced all of human knowledge, then floating around in spoken Vedic Sanskrit, into a generative grammar of exactly 3,995 <em>s≈´tras</em>, or rewrite rules - recorded in his magnum opus, the <em>A·π£·π≠ƒÅdhyƒÅyƒ´</em>. These rules have remained unchanged ever since.</p><p>Faced with a large corpus of spoken Vedic and contemporary Sanskrit, many thousands of hours of audio signals collected without any substrate to record with or automated tooling to work with, PƒÅ·πáini, over 12 years, found abstracted atoms of meaning that when combined with a set of dynamic rules and meta-rules formed a generative grammar, a deterministic state machine that could be used to re-synthesize the original audio corpus - and be recited in just 2 hours (an astonishing compression ratio of atleast ~5000:1)[3].</p><p>His work is the first formal system known to man, doing to linguistic reality what Euclid would go on to do later for geometry, but it would be no overstatement to recognize it the only example I&rsquo;ve seen of true optimal
<a href=https://en.m.wikipedia.org/wiki/Solomonoff%27s_theory_of_inductive_inference rel=noopener>Solomonoff induction</a> - finding the shortest unchanging executable archive of a dataset, as evidenced by it&rsquo;s durability over two millenia.</p><p>Indeed, the very existence of PƒÅ·πáini and his work disproves Searle&rsquo;s argument. Yes the machine in Searle&rsquo;s room doesn&rsquo;t understand Chinese, but there is someone in the system who does - the hidden compressor that created the rule table for the machine to lookup (a grammarian like PƒÅ·πáini). The compressor applied the dual techniques of abstraction and economy ruthlessly to thousands of noisy signals of various forms and fidelity, reducing them by many orders of magnitude into succinct set of formal predicates - deriving a fixed set of rules, an explanation unchanging in time. Like breaking down a house into basic Lego-like blocks and then building a new house from it back gain, the compressor like this could then combine these discovered reusable concepts on the fly using abstracted transformation rules to generalize to any unknown. Tomorrow if the raw source signals changed, the compressor would have a method to refactor the rules entirely for this new version of reality. The compressor is where the &ldquo;understanding&rdquo; is, the process of compression is where the true &ldquo;intelligence&rdquo; in the closed system resides.</p><p>When we talk about building intelligent machines, it is indeed building this compressor which we must talk about, NOT the fixed-in-time rules it discovers (a hand-written program, or a set of weights in a neural network). A digital superintelligence in action, would very much look like a grammarian on steroids, ruthlessly employing what we describe above as &ldquo;PƒÅ·πáini&rsquo;s Razor&rdquo;. It is the efficient, automated grammarian which is intelligent, not the ever-updating grammar it generated. Of course, PƒÅ·πáini was working with Sanskrit, whose underlying structure makes it less context-sensitive than English and more amenable to such decomposition. But for the sake of comparison, his methods if automated and applied to the
<a href=http://prize.hutter1.net/ rel=noopener>Hutter compression prize</a> dataset could compress 1GB of Wikipedia data to a few kilobytes (down from the current record of 110MB as of Feb 2025).</p><p>Searle would perhaps not have made the Chinese Room argument had he heard of PƒÅ·πáini&rsquo;s techniques. To build thinking machines of the future, we must not repeat his mistake.</p><a href=#pƒÅ·πáinis-razor><h2 id=pƒÅ·πáinis-razor><span class=hanchor arialabel=Anchor># </span>PƒÅ·πáini&rsquo;s Razor</h2></a><p>I have no formal training in Sanskrit, and the following is merely a programmer&rsquo;s attempt to reverse-engineer PƒÅ·πáini&rsquo;s methods of compression. This is largely a guide for other programmers, so we dive into code right away. Let&rsquo;s first look at how generative grammars compress information. All mistakes are mine.</p><p>Imagine you&rsquo;re trying to send the first 100 Fibonacci numbers to a friend. The naive approach would be to simply transmit these numbers directly. Let&rsquo;s see just how big this sequence gets:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>generate_fibonacci</span><span class=p>(</span><span class=n>n</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Generate first n Fibonacci numbers.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>sequence</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>sequence</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>sequence</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>sequence</span><span class=p>[</span><span class=o>-</span><span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sequence</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>fib_sequence</span> <span class=o>=</span> <span class=n>generate_fibonacci</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;First 100 Fibonacci numbers:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;, &#34;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>fib_sequence</span><span class=p>[:</span><span class=mi>10</span><span class=p>])</span> <span class=o>+</span> <span class=s2>&#34;...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;100th Fibonacci number: </span><span class=si>{</span><span class=n>fib_sequence</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>direct_bits</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>math</span><span class=o>.</span><span class=n>ceil</span><span class=p>(</span><span class=n>math</span><span class=o>.</span><span class=n>log2</span><span class=p>(</span><span class=n>x</span><span class=p>))</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>fib_sequence</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>Direct storage needs </span><span class=si>{</span><span class=n>direct_bits</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bits&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>First 100 Fibonacci numbers:
</span></span><span class=line><span class=cl>1, 1, 2, 3, 5, 8, 13, 21, 34, 55...
</span></span><span class=line><span class=cl>100th Fibonacci number: 354,224,848,179,261,915,075
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Direct storage needs 2,649 bits
</span></span></code></pre></td></tr></table></div></div><p>That&rsquo;s a lot of information! The numbers get very large very quickly - the 100th Fibonacci number is a 21-digit number. Let&rsquo;s see how different approaches to compression handle this much larger sequence.</p><a href=#the-building-blocks><h2 id=the-building-blocks><span class=hanchor arialabel=Anchor># </span>The Building Blocks</h2></a><p>We&rsquo;ll use two main classes to explore this idea:</p><ul><li><code>Rule</code>: Represents a production rule in our grammar, like &ldquo;S -> A B&rdquo; meaning &ldquo;S can be replaced with A followed by B&rdquo;</li><li><code>Grammar</code>: A collection of rules that can generate patterns, with methods to calculate how many bits we need to store it</li></ul><p>You can find the executable code in
<a href=https://github.com/sibeshkar/sibeshkar.github.io/blob/hugo/content/code/grammar.py rel=noopener><code>grammar.py</code></a>.</p><a href=#approach-1-naive-grammar---simple-memorization><h2 id=approach-1-naive-grammar---simple-memorization><span class=hanchor arialabel=Anchor># </span>Approach 1: Naive Grammar - Simple Memorization</h2></a><p>Let&rsquo;s start with the most straightforward approach - just writing down what we see:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Create a rule for each Fibonacci number</span>
</span></span><span class=line><span class=cl><span class=n>naive_rules</span> <span class=o>=</span> <span class=p>[</span><span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;F1&#39;</span><span class=p>])]</span> <span class=o>+</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;F</span><span class=si>{</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=p>[</span><span class=nb>str</span><span class=p>(</span><span class=n>num</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>num</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>fib_sequence</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>naive_grammar</span> <span class=o>=</span> <span class=n>Grammar</span><span class=p>(</span><span class=n>naive_rules</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>naive_bits</span> <span class=o>=</span> <span class=n>naive_grammar</span><span class=o>.</span><span class=n>description_length</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Naive grammar needs </span><span class=si>{</span><span class=n>naive_bits</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bits&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Compression ratio: </span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>naive_bits</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2>x&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Naive grammar needs 892 bits
</span></span><span class=line><span class=cl>Compression ratio: 2.97x
</span></span></code></pre></td></tr></table></div></div><p>This represents the most basic level of pattern recognition:</p><ul><li>‚úì Noticing that numbers can be labeled (F1, F2, etc.)</li><li>‚úì Understanding sequence order</li><li>‚úó No understanding of relationships between numbers</li><li>‚úó No recognition of the underlying pattern</li></ul><p>It&rsquo;s like a student who memorizes &ldquo;1, 1, 2, 3, 5, 8&mldr;&rdquo; without understanding why these numbers appear in this order. They achieve some compression just by being organized, but they&rsquo;re still essentially memorizing. Suppose we have 5.6TB of text data, ethically scraped from the internet, broken into word pairs (2-grams) stored in a lookup table. When asked to complete &ldquo;I was going to wear a&mldr;&rdquo;, it might meaninglessly output &ldquo;a lot&rdquo; because &ldquo;a lot&rdquo; appears more frequently than &ldquo;a shirt&rdquo; or &ldquo;a skirt&rdquo;. A 3-gram model, using two words of context, improves accuracy but still fails in cases like &ldquo;It&rsquo;s raining outside, wear a&mldr;&rdquo;. A memorized table like this would be an example of a generative models - predictingthe statistically-most-likely next word based on patterns in the data.</p><a href=#approach-2-pattern-recognition---seeing-relationships><h2 id=approach-2-pattern-recognition---seeing-relationships><span class=hanchor arialabel=Anchor># </span>Approach 2: Pattern Recognition - Seeing Relationships</h2></a><p>Now we start to notice relationships between numbers. This requires more sophisticated observation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>pattern_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=s1>&#39;N1&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;N1&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;1&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl><span class=p>]</span> <span class=o>+</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;N</span><span class=si>{</span><span class=n>fib</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=p>[</span><span class=nb>str</span><span class=p>(</span><span class=n>fib</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>fib</span> <span class=ow>in</span> <span class=nb>sorted</span><span class=p>(</span><span class=nb>set</span><span class=p>(</span><span class=n>fib_sequence</span><span class=p>[:</span><span class=mi>20</span><span class=p>]))</span>  <span class=c1># First 20 unique numbers</span>
</span></span><span class=line><span class=cl><span class=p>]</span> <span class=o>+</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;N1&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;N1&#39;</span><span class=p>,</span> <span class=s1>&#39;+&#39;</span><span class=p>,</span> <span class=s1>&#39;N1&#39;</span><span class=p>]),</span>  <span class=c1># 1 + 1 = 2</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;N2&#39;</span><span class=p>,</span> <span class=s1>&#39;+&#39;</span><span class=p>,</span> <span class=s1>&#39;N3&#39;</span><span class=p>]),</span>  <span class=c1># 2 + 3 = 5</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;N3&#39;</span><span class=p>,</span> <span class=s1>&#39;+&#39;</span><span class=p>,</span> <span class=s1>&#39;N5&#39;</span><span class=p>]),</span>  <span class=c1># 3 + 5 = 8</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;N5&#39;</span><span class=p>,</span> <span class=s1>&#39;+&#39;</span><span class=p>,</span> <span class=s1>&#39;N8&#39;</span><span class=p>]),</span>  <span class=c1># 5 + 8 = 13</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>pattern_grammar</span> <span class=o>=</span> <span class=n>Grammar</span><span class=p>(</span><span class=n>pattern_rules</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>pattern_bits</span> <span class=o>=</span> <span class=n>pattern_grammar</span><span class=o>.</span><span class=n>description_length</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Pattern grammar needs </span><span class=si>{</span><span class=n>pattern_bits</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bits&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Compression ratio: </span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>pattern_bits</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2>x&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Pattern grammar needs 428 bits
</span></span><span class=line><span class=cl>Compression ratio: 6.19x
</span></span></code></pre></td></tr></table></div></div><p>This represents an intermediate level of understanding:</p><ul><li>‚úì Recognition that numbers are related through addition</li><li>‚úì Ability to see specific instances of the pattern</li><li>‚úó Still manually writing out each addition step</li><li>‚úó No recognition of the recursive nature</li><li>‚úó Can&rsquo;t generate numbers beyond what&rsquo;s explicitly coded</li></ul><p>It&rsquo;s like a student who realizes &ldquo;Oh, I can get each number by adding specific previous numbers!&rdquo; They&rsquo;re starting to see relationships, but they&rsquo;re still writing out each step manually. They might even make a table:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1 + 1 = 2
</span></span><span class=line><span class=cl>2 + 3 = 5
</span></span><span class=line><span class=cl>3 + 5 = 8
</span></span></code></pre></td></tr></table></div></div><p>This is better than memorization, but they haven&rsquo;t yet had their &ldquo;aha!&rdquo; moment.</p><a href=#approach-3-full-abstraction---the-cognitive-leap><h2 id=approach-3-full-abstraction---the-cognitive-leap><span class=hanchor arialabel=Anchor># </span>Approach 3: Full Abstraction - The Cognitive Leap</h2></a><p>Finally, we make the cognitive leap to understand the deep structure:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>abstract_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=s1>&#39;1&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;1&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=s1>&#39;+&#39;</span><span class=p>,</span> <span class=s1>&#39;F_prev&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>abstract_grammar</span> <span class=o>=</span> <span class=n>Grammar</span><span class=p>(</span><span class=n>abstract_rules</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>abstract_bits</span> <span class=o>=</span> <span class=n>abstract_grammar</span><span class=o>.</span><span class=n>description_length</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Abstract grammar needs </span><span class=si>{</span><span class=n>abstract_bits</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bits&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Compression ratio: </span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>abstract_bits</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2>x&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Abstract grammar needs 14 bits
</span></span><span class=line><span class=cl>Compression ratio: 189.21x
</span></span></code></pre></td></tr></table></div></div><p>This represents the highest level of understanding, requiring several cognitive breakthroughs:</p><ul><li>‚úì Recognition that each number depends on the previous TWO numbers</li><li>‚úì Understanding that this single relationship explains EVERY number</li><li>‚úì Grasping that you don&rsquo;t need to store the numbers themselves</li><li>‚úì Realizing the pattern is recursive and self-contained</li><li>‚úì Understanding that this works for ANY length sequence</li></ul><p>The cognitive steps to reach this understanding typically involve:</p><ol><li>Noticing that you&rsquo;re always adding two numbers</li><li>Realizing those two numbers are always the previous ones</li><li>The key insight: this ONE rule explains EVERYTHING</li><li>Understanding that with just this rule and a starting point, you can generate the entire sequence</li></ol><p>It&rsquo;s like the student who suddenly exclaims &ldquo;Wait&mldr; we&rsquo;re ALWAYS just adding the last two numbers! That&rsquo;s all we need to know!&rdquo; This is the moment of true understanding, where the pattern becomes crystal clear and beautifully simple.</p><a href=#generating-the-sequence><h2 id=generating-the-sequence><span class=hanchor arialabel=Anchor># </span>Generating the Sequence</h2></a><p>The beauty of this abstract grammar is that it&rsquo;s not just for compression - we can use it to regenerate the original sequence or extend it to any length we want:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>generate_fibonacci</span><span class=p>(</span><span class=n>n</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Generate first n Fibonacci numbers using our grammar rules.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>sequence</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>]</span>  <span class=c1># Initial state from our grammar&#39;s rules</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>sequence</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>sequence</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>sequence</span><span class=p>[</span><span class=o>-</span><span class=mi>2</span><span class=p>])</span>  <span class=c1># F -&gt; F + F_prev rule</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sequence</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Test the generator</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Regenerating our sequence:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>generate_fibonacci</span><span class=p>(</span><span class=mi>10</span><span class=p>))</span>  <span class=c1># First 10 numbers</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>Extending beyond what we originally stored:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>generate_fibonacci</span><span class=p>(</span><span class=mi>15</span><span class=p>))</span>  <span class=c1># First 15 numbers</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Regenerating our sequence:
</span></span><span class=line><span class=cl>[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Extending beyond what we originally stored:
</span></span><span class=line><span class=cl>[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]
</span></span></code></pre></td></tr></table></div></div><p>This demonstrates the true power of understanding the generative process: with just 14 bits of grammar rules, we can:</p><ol><li>Reproduce the original sequence exactly</li><li>Generate any Fibonacci number we want</li><li>Extend the sequence infinitely</li></ol><p>The massive improvement in compression ratio (189.21x vs 2.97x) reflects this deep understanding. We&rsquo;ve gone from:</p><ul><li>Memorizing 100 numbers (naive) ‚Üí</li><li>Understanding specific additions (pattern) ‚Üí</li><li>Grasping the universal rule (abstract)</li></ul><p>This progression mirrors how humans learn: from memorization, to pattern recognition, to true understanding. The fact that better understanding leads to better compression isn&rsquo;t just a mathematical curiosity - it&rsquo;s a fundamental principle of how we make sense of the world.</p><p>Let&rsquo;s visualize these compression ratios:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>Compression Comparison:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;=&#34;</span> <span class=o>*</span> <span class=mi>50</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Direct storage:     </span><span class=si>{</span><span class=n>direct_bits</span><span class=si>:</span><span class=s2>6,</span><span class=si>}</span><span class=s2> bits (baseline)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Naive grammar:      </span><span class=si>{</span><span class=n>naive_bits</span><span class=si>:</span><span class=s2>6,</span><span class=si>}</span><span class=s2> bits (</span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>naive_bits</span><span class=si>:</span><span class=s2>6.2f</span><span class=si>}</span><span class=s2>x better)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Pattern grammar:    </span><span class=si>{</span><span class=n>pattern_bits</span><span class=si>:</span><span class=s2>6,</span><span class=si>}</span><span class=s2> bits (</span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>pattern_bits</span><span class=si>:</span><span class=s2>6.2f</span><span class=si>}</span><span class=s2>x better)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Abstract grammar:   </span><span class=si>{</span><span class=n>abstract_bits</span><span class=si>:</span><span class=s2>6,</span><span class=si>}</span><span class=s2> bits (</span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>abstract_bits</span><span class=si>:</span><span class=s2>6.2f</span><span class=si>}</span><span class=s2>x better)&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Compression Comparison:
</span></span><span class=line><span class=cl>==================================================
</span></span><span class=line><span class=cl>Direct storage:      2,649 bits (baseline)
</span></span><span class=line><span class=cl>Naive grammar:         892 bits (  2.97x better)
</span></span><span class=line><span class=cl>Pattern grammar:       428 bits (  6.19x better)
</span></span><span class=line><span class=cl>Abstract grammar:       14 bits (189.21x better)
</span></span></code></pre></td></tr></table></div></div><p>This dramatic improvement shows the true power of finding the underlying generative process. The more data we have, the more valuable it becomes to understand the true pattern rather than just storing or partially compressing the output.</p><a href=#from-numbers-to-language><h2 id=from-numbers-to-language><span class=hanchor arialabel=Anchor># </span>From Numbers to Language</h2></a><p>Let&rsquo;s apply the same thinking to language patterns. Here&rsquo;s a set of similar sentences:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>sentences</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;I like cats and dogs&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;I like books and music&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;I like coffee and tea&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;I like movies and games&#34;</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>direct_bits</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>*</span> <span class=mi>8</span> <span class=k>for</span> <span class=n>s</span> <span class=ow>in</span> <span class=n>sentences</span><span class=p>)</span>  <span class=c1># 8 bits per char</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Direct storage needs </span><span class=si>{</span><span class=n>direct_bits</span><span class=si>}</span><span class=s2> bits&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Direct storage needs 688 bits
</span></span></code></pre></td></tr></table></div></div><p>That&rsquo;s a lot of bits! Let&rsquo;s try our different approaches:</p><a href=#naive-grammar-store-each-sentence><h3 id=naive-grammar-store-each-sentence><span class=hanchor arialabel=Anchor># </span>Naive Grammar (Store Each Sentence):</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>naive_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;I&#39;</span><span class=p>,</span> <span class=s1>&#39;like&#39;</span><span class=p>,</span> <span class=s1>&#39;cats&#39;</span><span class=p>,</span> <span class=s1>&#39;and&#39;</span><span class=p>,</span> <span class=s1>&#39;dogs&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;I&#39;</span><span class=p>,</span> <span class=s1>&#39;like&#39;</span><span class=p>,</span> <span class=s1>&#39;books&#39;</span><span class=p>,</span> <span class=s1>&#39;and&#39;</span><span class=p>,</span> <span class=s1>&#39;music&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;I&#39;</span><span class=p>,</span> <span class=s1>&#39;like&#39;</span><span class=p>,</span> <span class=s1>&#39;coffee&#39;</span><span class=p>,</span> <span class=s1>&#39;and&#39;</span><span class=p>,</span> <span class=s1>&#39;tea&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;I&#39;</span><span class=p>,</span> <span class=s1>&#39;like&#39;</span><span class=p>,</span> <span class=s1>&#39;movies&#39;</span><span class=p>,</span> <span class=s1>&#39;and&#39;</span><span class=p>,</span> <span class=s1>&#39;games&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>naive_grammar</span> <span class=o>=</span> <span class=n>Grammar</span><span class=p>(</span><span class=n>naive_rules</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>naive_bits</span> <span class=o>=</span> <span class=n>naive_grammar</span><span class=o>.</span><span class=n>description_length</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Naive grammar needs </span><span class=si>{</span><span class=n>naive_bits</span><span class=si>}</span><span class=s2> bits (compression ratio: </span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>naive_bits</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2>x)&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Naive grammar needs 63 bits (compression ratio: 10.92x)
</span></span></code></pre></td></tr></table></div></div><p>Just by recognizing words as reusable symbols, we get almost 11x compression!</p><a href=#pattern-recognition-find-common-structure><h3 id=pattern-recognition-find-common-structure><span class=hanchor arialabel=Anchor># </span>Pattern Recognition (Find Common Structure):</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>pattern_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;I&#39;</span><span class=p>,</span> <span class=s1>&#39;like&#39;</span><span class=p>,</span> <span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=s1>&#39;and&#39;</span><span class=p>,</span> <span class=s1>&#39;THING&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;cats&#39;</span><span class=p>]),</span> <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;dogs&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;books&#39;</span><span class=p>]),</span> <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;music&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;coffee&#39;</span><span class=p>]),</span> <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;tea&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;movies&#39;</span><span class=p>]),</span> <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;games&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>pattern_grammar</span> <span class=o>=</span> <span class=n>Grammar</span><span class=p>(</span><span class=n>pattern_rules</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>pattern_bits</span> <span class=o>=</span> <span class=n>pattern_grammar</span><span class=o>.</span><span class=n>description_length</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Pattern grammar needs </span><span class=si>{</span><span class=n>pattern_bits</span><span class=si>}</span><span class=s2> bits (compression ratio: </span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>pattern_bits</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2>x)&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Pattern grammar needs 30 bits (compression ratio: 22.93x)
</span></span></code></pre></td></tr></table></div></div><p>By recognizing that we can reuse the pattern &ldquo;I like X and Y&rdquo;, we get even better compression!</p><a href=#full-abstraction-separate-first-and-second-items><h3 id=full-abstraction-separate-first-and-second-items><span class=hanchor arialabel=Anchor># </span>Full Abstraction (Separate First and Second Items):</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>abstract_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;I&#39;</span><span class=p>,</span> <span class=s1>&#39;like&#39;</span><span class=p>,</span> <span class=s1>&#39;N1&#39;</span><span class=p>,</span> <span class=s1>&#39;and&#39;</span><span class=p>,</span> <span class=s1>&#39;N2&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;N1&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;cats&#39;</span><span class=p>,</span> <span class=s1>&#39;books&#39;</span><span class=p>,</span> <span class=s1>&#39;coffee&#39;</span><span class=p>,</span> <span class=s1>&#39;movies&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;N2&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;dogs&#39;</span><span class=p>,</span> <span class=s1>&#39;music&#39;</span><span class=p>,</span> <span class=s1>&#39;tea&#39;</span><span class=p>,</span> <span class=s1>&#39;games&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>abstract_grammar</span> <span class=o>=</span> <span class=n>Grammar</span><span class=p>(</span><span class=n>abstract_rules</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>abstract_bits</span> <span class=o>=</span> <span class=n>abstract_grammar</span><span class=o>.</span><span class=n>description_length</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Abstract grammar needs </span><span class=si>{</span><span class=n>abstract_bits</span><span class=si>}</span><span class=s2> bits (compression ratio: </span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>abstract_bits</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2>x)&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Abstract grammar needs 39 bits (compression ratio: 17.64x)
</span></span></code></pre></td></tr></table></div></div><p>Interestingly, trying to be too clever (separating first and second items) actually hurts our compression! This is a key insight: the best compression comes from matching the true structure of the data.</p><a href=#the-challenge-of-english-grammar><h3 id=the-challenge-of-english-grammar><span class=hanchor arialabel=Anchor># </span>The Challenge of English Grammar</h3></a><p>However, English presents a challenge for such clean abstractions. Unlike our previous examples, English is a context-sensitive language, which means the interpretation of a word or phrase often depends on its context. For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>context_examples</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;The bank is closed&#34;</span> <span class=p>,</span>           <span class=c1># Financial institution</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;The bank is muddy&#34;</span><span class=p>,</span>            <span class=c1># River bank</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;I bank on your support&#34;</span><span class=p>,</span>       <span class=c1># Rely/depend</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;The plane will bank left&#34;</span>      <span class=c1># Aviation term</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>This context sensitivity means the same word can have different meanings based on surrounding words, the same grammatical structure can have different interpretations, and valid combinations depend on semantic meaning, not just syntax.</p><p>This limits how much we can compress English using pure grammatical rules. Our compression ratio of 22.93x was possible because we used a very restricted subset of English. In the general case, we would need better rules about how context influences meaning, better word sense disambiguation etc.</p><p>This is why formal languages (like programming languages) and some natural languages with more rigid structure achieve better compression ratios.</p><a href=#a-more-compressible-language><h3 id=a-more-compressible-language><span class=hanchor arialabel=Anchor># </span>A More Compressible Language</h3></a><p>some more ancient languages like Sanskrit (and Greek) turn out to have a structure more amenable to rule-based generation. This isbecause:</p><ol><li>Words are derived from root forms using explicit rules</li><li>Compound words follow clear compositional rules</li><li>Sentence structure has more rigid constraints</li><li>Word meanings are more systematically related to their roots</li></ol><p>This makes a language like Sanskrit more like our Fibonacci sequence - there are clear generative rules that can produce valid constructions.</p><a href=#pƒÅ·πáinis-method-in-action><h3 id=pƒÅ·πáinis-method-in-action><span class=hanchor arialabel=Anchor># </span>PƒÅ·πáini&rsquo;s Method in Action</h3></a><p>Let&rsquo;s look at some concrete examples of how PƒÅ·πáini&rsquo;s grammar generates Sanskrit words and sentences:</p><ol><li><p><strong>Root-Based Word Generation</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Example: Generating forms of &#34;bh≈´&#34; (to be)</span>
</span></span><span class=line><span class=cl><span class=n>root_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;VERB&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;ROOT&#39;</span><span class=p>,</span> <span class=s1>&#39;SUFFIX&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;ROOT&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;bh≈´&#39;</span><span class=p>]),</span>  <span class=c1># &#34;to be&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;SUFFIX&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;ami&#39;</span><span class=p>]),</span>  <span class=c1># 1st person present</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;SUFFIX&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;asi&#39;</span><span class=p>]),</span>  <span class=c1># 2nd person present</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;SUFFIX&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;ati&#39;</span><span class=p>])</span>   <span class=c1># 3rd person present</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>This generates:</p><ul><li>bhavƒÅmi (I am)</li><li>bhavasi (you are)</li><li>bhavati (he/she/it is)</li></ul><p>The transformation bh≈´ ‚Üí bhav is handled by another rule (gu·πáa strengthening). When the root &lsquo;bh≈´&rsquo; combines with certain suffixes, this rule changes the &lsquo;≈´&rsquo; sound to &lsquo;av&rsquo;, demonstrating how PƒÅ·πáini&rsquo;s system handles systematic sound (phonological) changes that occur when morphemes combine.</p></li><li><p><strong>Compound Word Formation</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Example: Generating compound words</span>
</span></span><span class=line><span class=cl><span class=n>compound_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;COMPOUND&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;WORD1&#39;</span><span class=p>,</span> <span class=s1>&#39;WORD2&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;WORD1&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;rƒÅja&#39;</span><span class=p>]),</span>  <span class=c1># king</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;WORD2&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;putra&#39;</span><span class=p>])</span>  <span class=c1># son</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>sandhi_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;SANDHI&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=s1>&#39;a&#39;</span><span class=p>],</span> <span class=p>[</span><span class=s1>&#39;ƒÅ&#39;</span><span class=p>]),</span>  <span class=c1># a + a ‚Üí ƒÅ</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>This generates:</p><ul><li>rƒÅja + putra ‚Üí rƒÅjaputra (king&rsquo;s son)
The rules handle both combination and sound changes (sandhi).</li></ul></li><li><p><strong>Sentence Structure</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Example: Generating active/passive sentences</span>
</span></span><span class=line><span class=cl><span class=n>sentence_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;NP&#39;</span><span class=p>,</span> <span class=s1>&#39;VP&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;NP&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;devadatta&#39;</span><span class=p>]),</span>  <span class=c1># Devadatta (name)</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;VP&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;odana·πÉ&#39;</span><span class=p>,</span> <span class=s1>&#39;pacati&#39;</span><span class=p>]),</span>  <span class=c1># rice + cooks</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;VP_PASSIVE&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;odana·∏•&#39;</span><span class=p>,</span> <span class=s1>&#39;pacyate&#39;</span><span class=p>])</span>  <span class=c1># rice + is cooked</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>This generates:</p><ul><li>devadatta·∏• odana·πÉ pacati (Devadatta cooks rice)</li><li>odana·∏• pacyate (Rice is cooked)</li></ul></li></ol><p>The power of PƒÅ·πáini&rsquo;s system comes from how these rules interact:</p><ol><li><p><strong>Recursive Application</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Example: Complex word formation</span>
</span></span><span class=line><span class=cl><span class=n>derivation_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;WORD&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;ROOT&#39;</span><span class=p>,</span> <span class=s1>&#39;PRIMARY_SUFFIX&#39;</span><span class=p>,</span> <span class=s1>&#39;SECONDARY_SUFFIX&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;ROOT&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;bh≈´&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;PRIMARY_SUFFIX&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;ana&#39;</span><span class=p>]),</span>  <span class=c1># action noun</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;SECONDARY_SUFFIX&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;tva&#39;</span><span class=p>])</span>  <span class=c1># abstract quality</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>This generates:</p><ul><li>bh≈´ ‚Üí bhavana (becoming) ‚Üí bhavanatva (the quality of becoming)</li></ul></li><li><p><strong>Meta-Rules</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Example: Rule ordering</span>
</span></span><span class=line><span class=cl><span class=n>meta_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;APPLY_ORDER&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;ROOT_RULES&#39;</span><span class=p>,</span> <span class=s1>&#39;SANDHI_RULES&#39;</span><span class=p>,</span> <span class=s1>&#39;ACCENT_RULES&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;EXCEPTION&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;if_final_position&#39;</span><span class=p>,</span> <span class=s1>&#39;skip_sandhi&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><p>These meta-rules ensure correct application order and handle exceptions systematically.</p><p>We see PƒÅ·πáini&rsquo;s approach compresses his original corpus by many orders of magnitude by systematically doing <em>more</em> with <em>less</em>:</p><ol><li>Each rule can generate many forms (e.g., one verb root rule generates hundreds of conjugations)</li><li>Rules interact to produce complex forms (like compounds and derivatives)</li><li>Meta-rules handle exceptions without needing separate rules for each case</li><li>The system captures both form (phonology) and meaning (semantics)</li></ol><p>For example, from just the root &ldquo;bh≈´&rdquo; and a set of rules, PƒÅ·πáini&rsquo;s grammar can generate:</p><ul><li>All conjugated forms (bhavƒÅmi, bhavasi, bhavati, etc.)</li><li>All derived nouns (bhavana, bhƒÅva, bh≈´ti, etc.)</li><li>All compounds (bh≈´loka - world of existence, bh≈´tap≈´rva - having been before, etc.)</li><li>All these forms in different syntactic roles</li></ul><p>This is analogous to our Fibonacci example, where one simple rule (Fn = Fn-1 + Fn-2) generates an infinite sequence. But PƒÅ·πáini&rsquo;s grammar goes further, handling multiple interacting patterns simultaneously while maintaining semantic coherence. There are infact two remarkable things to notice here:</p><ol><li>He was building on some previous work, but that a human with no tooling/computation access could speedrun a 5000x compression in a lifetime is astonishing. A 21st century analogue would be if Linus Torvalds hand-wrote the final, complete, version of Linux on his first try without access to a compiler - the final version which would never require any patches/fixes after creation.</li><li>It&rsquo;s bizarre that an unchanging centralized rule-based generative order even exists for an evolving spoken language that was decentralized in its usage - and this formalism was lying there waiting to be discovered, like one would think of a theory of gravity. It&rsquo;s like counting the seed spirals of a sunflower and finding that they always follow some predetermined recursive Fibonacci sequence (
<a href=https://royalsocietypublishing.org/doi/10.1098/rsos.160091 rel=noopener>which they do!</a>), or appear in fixed golden ratios of Phi (1.618&mldr;). This is a discussion for another day.</li></ol><blockquote><p>&ldquo;The descriptive grammar of Sanskrit which PƒÅ·πáini brought to it&rsquo;s highest perfection is one of the greatest monuments of human intelligence&rdquo; - L. Bloomfield, father of American distributionalism</p></blockquote><p>How is PƒÅ·πáini&rsquo;s ~4000 rule set a compressed generative model like one would understand an LLM to be? Imagine prompting an LLM like ChatGPT with an empty prompt, and letting it run for a few paragraphs. If you did this a trillion times, with slightly different temperature settings, you would eventually recover a slightly morphed version of the entire corpus it was trained on. &lsquo;Model distillation&rsquo; is the industry term for this common practice, used to copy parts of another LLM&rsquo;s training set. In a similar manner, if you were to run the state machine described in the <em>A·π£·π≠ƒÅdhyƒÅyƒ´</em> a billion times with random inputs, you would eventually recover all the Vedic hymns, mantras, and Brahmanas it compresses, include the different variations of spoken Sanskrit. Of course, just like you guide an LLM&rsquo;s output by including an input prompt, you would need to guide the state machine in the <em>A·π£·π≠ƒÅdhyƒÅyƒ´</em> to generate the <em>kind</em> of sentences you wanted. But the complexity of the original source remains contained in the abstracted, highly compressed rule set.</p><p>This brings us to a crucial insight about building machine intelligence. The key to achieving a ~5000:1 compression ratio like PƒÅ·πáini did, lies not in the lookup tables of Searle&rsquo;s Chinese Room, but in the process that created those tables - the hidden PƒÅ·πáini-like compressor that could derive rules like the one above through the repeated application of abstraction and economy. Let&rsquo;s next try to understand what making an automated grammarian might look like.</p><a href=#from-numbers-to-pƒÅ·πáini-the-first-computational-grammarian><h2 id=from-numbers-to-pƒÅ·πáini-the-first-computational-grammarian><span class=hanchor arialabel=Anchor># </span>From Numbers to PƒÅ·πáini: The First Computational Grammarian</h2></a><p>How might PƒÅ·πáini have done it? let&rsquo;s look at our own process of compressing the Fibonacci sequence:</p><ol><li>Start with examples (like our Fibonacci numbers or sentences)</li><li>Look for patterns (like our pattern recognition phase)</li><li>Abstract to rules (like our final recursive sgrammars)</li></ol><p>PƒÅ·πáini likely followed a similar path:</p><ol><li><strong>Data Collection</strong>: Gathered/recorded thousands of source material (~10,000 hours of spoken Sanskrit)</li><li><strong>Pattern Recognition</strong>: Identified recurring structures</li><li><strong>Rule Abstraction</strong>: Derived minimal generative rules, meta-rules, and exceptions</li><li><strong>Optimization</strong>: Compressed rules for memorization (~reduced to 2 hours of ~4000 rules that can be memorized)</li></ol><p>In the case of the fibonacci sequence, the method achieves a compression ratio of 189.21x, in the case of Sanskrit, PƒÅ·πáini&rsquo;s grammar achieves a compression ratio of ~5000:1:.</p><p>What makes PƒÅ·πáini&rsquo;s work particularly relevant to our discussion is that it demonstrates the same principles we&rsquo;ve discovered with compressing Fibonacci sequences:</p><ol><li><p><strong>Cognitive Progression</strong>: Like our Fibonacci example progressing from naive to abstract, from memorizing words to understanding derivation rules</p></li><li><p><strong>Minimal Description</strong>: Like our abstract Fibonacci grammar using just 3 rules, his grammar captures an entire language in ~4,000 rules</p></li><li><p><strong>Generative Power</strong>: Like our abstract grammars generating infinite sequences, his system can generate all valid Sanskrit constructions</p></li></ol><a href=#from-ancient-grammar-to-modern-systems--the-case-of-pong><h2 id=from-ancient-grammar-to-modern-systems--the-case-of-pong><span class=hanchor arialabel=Anchor># </span>From Ancient Grammar to Modern Systems : The Case of Pong</h2></a><p>While PƒÅ·πáini&rsquo;s work on Sanskrit grammar might seem purely academic, this method of identifying patterns, finding minimal rules, and using them to generate valid outputs can be applied far beyond language - it provides a universal framework for understanding and compressing any complex system, allowing us to generate infinite valid states from a small set of core rules.</p><p>The real power of PƒÅ·πáini&rsquo;s compression approach to generative grammars becomes clear when we apply it to modelling more complex systems with real-world state machines - like video games. Just as PƒÅ·πáini found that all of Sanskrit could be generated from ~4,000 rules, we&rsquo;ll see how an entire game can be generated from just 8 rules. Let&rsquo;s look at how we could compress a recording of a Pong game:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>PongGrammar</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>            <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;GAME&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;INIT&#39;</span><span class=p>,</span> <span class=s1>&#39;LOOP&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>            <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;INIT&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;Ball(center)&#39;</span><span class=p>,</span> <span class=s1>&#39;Paddle1(mid)&#39;</span><span class=p>,</span> <span class=s1>&#39;Paddle2(mid)&#39;</span><span class=p>,</span> <span class=s1>&#39;Score(0,0)&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>            <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;LOOP&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;UPDATE&#39;</span><span class=p>,</span> <span class=s1>&#39;COLLISIONS&#39;</span><span class=p>,</span> <span class=s1>&#39;SCORE&#39;</span><span class=p>,</span> <span class=s1>&#39;LOOP&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>            <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;UPDATE&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;Ball(pos += vel)&#39;</span><span class=p>,</span> <span class=s1>&#39;Paddle1(pos += input1)&#39;</span><span class=p>,</span> <span class=s1>&#39;Paddle2(pos += input2)&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>            <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;COLLISIONS&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;WALL_CHECK&#39;</span><span class=p>,</span> <span class=s1>&#39;PADDLE_CHECK&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>            <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;WALL_CHECK&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;if ball.y &gt; height: ball.vel.y *= -1&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>            <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;PADDLE_CHECK&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;if ball.collides(paddle): ball.vel.x *= -1&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>            <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;SCORE&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;if ball.x &lt; 0: p2_score++ else if ball.x &gt; width: p1_score++&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>        <span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>grammar</span> <span class=o>=</span> <span class=n>Grammar</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>rules</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Let&#39;s calculate sizes for a 5-minute game at 60 FPS</span>
</span></span><span class=line><span class=cl><span class=n>frames</span> <span class=o>=</span> <span class=mi>300</span> <span class=o>*</span> <span class=mi>60</span>  <span class=c1># 5 minutes at 60 FPS</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># First, let&#39;s look at a conservative estimate (just storing positions)</span>
</span></span><span class=line><span class=cl><span class=n>pos_frame_size</span> <span class=o>=</span> <span class=p>(</span><span class=mi>4</span> <span class=o>+</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>8</span><span class=p>)</span>  <span class=c1># 4 bytes each for paddles, 8 for ball position</span>
</span></span><span class=line><span class=cl><span class=n>pos_raw_size</span> <span class=o>=</span> <span class=n>pos_frame_size</span> <span class=o>*</span> <span class=n>frames</span>
</span></span><span class=line><span class=cl><span class=n>grammar_size</span> <span class=o>=</span> <span class=n>pong</span><span class=o>.</span><span class=n>grammar</span><span class=o>.</span><span class=n>description_length</span><span class=p>()</span>  <span class=c1># Rules of the game</span>
</span></span><span class=line><span class=cl><span class=n>input_size</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>frames</span>  <span class=c1># 1 bit per paddle per frame</span>
</span></span><span class=line><span class=cl><span class=n>state_size</span> <span class=o>=</span> <span class=mi>16</span>  <span class=c1># 4 bytes each for ball x,y and two paddle positions</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Conservative Estimate (Position Data Only)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;=========================================&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Raw position data:   </span><span class=si>{</span><span class=n>pos_raw_size</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bytes (</span><span class=si>{</span><span class=n>pos_raw_size</span><span class=o>/</span><span class=mi>1024</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> KB)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Grammar + state:     </span><span class=si>{</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bytes (</span><span class=si>{</span><span class=p>(</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=p>)</span><span class=o>/</span><span class=mi>1024</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> KB)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Compression ratio:   </span><span class=si>{</span><span class=n>pos_raw_size</span><span class=o>/</span><span class=p>(</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=p>)</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2>x&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Now let&#39;s look at the full visual data</span>
</span></span><span class=line><span class=cl><span class=n>frame_height</span> <span class=o>=</span> <span class=mi>210</span>
</span></span><span class=line><span class=cl><span class=n>frame_width</span> <span class=o>=</span> <span class=mi>160</span>
</span></span><span class=line><span class=cl><span class=n>channels</span> <span class=o>=</span> <span class=mi>3</span>  <span class=c1># RGB</span>
</span></span><span class=line><span class=cl><span class=n>pixel_frame_size</span> <span class=o>=</span> <span class=n>frame_height</span> <span class=o>*</span> <span class=n>frame_width</span> <span class=o>*</span> <span class=n>channels</span>  <span class=c1># bytes per frame</span>
</span></span><span class=line><span class=cl><span class=n>pixel_raw_size</span> <span class=o>=</span> <span class=n>pixel_frame_size</span> <span class=o>*</span> <span class=n>frames</span>  <span class=c1># Full video storage</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>Full Visual Data Estimate (Every Pixel)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;=======================================&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Frame dimensions: </span><span class=si>{</span><span class=n>frame_width</span><span class=si>}</span><span class=s2>x</span><span class=si>{</span><span class=n>frame_height</span><span class=si>}</span><span class=s2> pixels (RGB)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Storage requirements:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;- Raw video:        </span><span class=si>{</span><span class=n>pixel_raw_size</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bytes (</span><span class=si>{</span><span class=n>pixel_raw_size</span><span class=o>/</span><span class=mi>1024</span><span class=o>/</span><span class=mi>1024</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> MB)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;- Grammar rules:    </span><span class=si>{</span><span class=n>grammar_size</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bytes&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;- Player inputs:    </span><span class=si>{</span><span class=n>input_size</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bytes&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;- Game state:       </span><span class=si>{</span><span class=n>state_size</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bytes&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;- Total compressed: </span><span class=si>{</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bytes (</span><span class=si>{</span><span class=p>(</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=p>)</span><span class=o>/</span><span class=mi>1024</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> KB)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Compression ratio:  </span><span class=si>{</span><span class=n>pixel_raw_size</span><span class=o>/</span><span class=p>(</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=p>)</span><span class=si>:</span><span class=s2>,.2f</span><span class=si>}</span><span class=s2>x&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># To put this in perspective:</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>To store a 5-minute Pong game:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;1. Conservative Approach (Just Positions)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;   - Raw data: </span><span class=si>{</span><span class=n>pos_raw_size</span><span class=o>/</span><span class=mi>1024</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> KB&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;   - Compressed: </span><span class=si>{</span><span class=p>(</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=p>)</span><span class=o>/</span><span class=mi>1024</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> KB&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;   - Ratio: </span><span class=si>{</span><span class=n>pos_raw_size</span><span class=o>/</span><span class=p>(</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=p>)</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2>x better&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>2. Full Visual Approach (Every Pixel)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;   - Raw data: </span><span class=si>{</span><span class=n>pixel_raw_size</span><span class=o>/</span><span class=mi>1024</span><span class=o>/</span><span class=mi>1024</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> MB&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;   - Compressed: </span><span class=si>{</span><span class=p>(</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=p>)</span><span class=o>/</span><span class=mi>1024</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> KB&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;   - Ratio: </span><span class=si>{</span><span class=n>pixel_raw_size</span><span class=o>/</span><span class=p>(</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=p>)</span><span class=si>:</span><span class=s2>,.2f</span><span class=si>}</span><span class=s2>x better&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Conservative Estimate (Position Data Only)
</span></span><span class=line><span class=cl>=========================================
</span></span><span class=line><span class=cl>Raw position data:   1,872,000 bytes (1,828.1 KB)
</span></span><span class=line><span class=cl>Grammar + state:     38,064 bytes (37.2 KB)
</span></span><span class=line><span class=cl>Compression ratio:   49.18x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Full Visual Data Estimate (Every Pixel)
</span></span><span class=line><span class=cl>=======================================
</span></span><span class=line><span class=cl>Frame dimensions: 160x210 pixels (RGB)
</span></span><span class=line><span class=cl>Storage requirements:
</span></span><span class=line><span class=cl>- Raw video:        18,144,000,000 bytes (17,304.7 MB)
</span></span><span class=line><span class=cl>- Grammar rules:    2,048 bytes
</span></span><span class=line><span class=cl>- Player inputs:    36,000 bytes
</span></span><span class=line><span class=cl>- Game state:       16 bytes
</span></span><span class=line><span class=cl>- Total compressed: 38,064 bytes (37.2 KB)
</span></span><span class=line><span class=cl>Compression ratio:  476,671.45x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>To store a 5-minute Pong game:
</span></span><span class=line><span class=cl>1. Conservative Approach (Just Positions)
</span></span><span class=line><span class=cl>   - Raw data: 1,828.1 KB
</span></span><span class=line><span class=cl>   - Compressed: 37.2 KB
</span></span><span class=line><span class=cl>   - Ratio: 49.18x better
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>2. Full Visual Approach (Every Pixel)&#34;
</span></span><span class=line><span class=cl>   - Raw data: 17,304.7 MB
</span></span><span class=line><span class=cl>   - Compressed: 37.2 KB
</span></span><span class=line><span class=cl>   - Ratio: 476,671.45x better
</span></span></code></pre></td></tr></table></div></div><p>This is remarkable in two ways:</p><ol><li><p><strong>Conservative Estimate</strong> (Just storing positions):</p><ul><li>Raw data: ~1.8 MB</li><li>Compressed: ~37 KB</li><li>Nearly 50x compression just for the game state!</li></ul></li><li><p><strong>Full Visual Data</strong> (Every pixel of every frame):</p><ul><li>Raw data: ~17.3 GB</li><li>Compressed: ~37 KB</li><li>Almost 500,000x compression!</li></ul></li></ol><p>Even our conservative estimate shows impressive compression because we&rsquo;re capturing the underlying game logic. But when we consider that this same grammar can generate the complete visual output, the compression becomes staggering. We achieve this because:</p><ol><li>The rules of the game (our grammar) - about 2KB</li><li>The player inputs - about 35KB</li><li>The game state - just 16 bytes</li></ol><p>The grammar captures both the physics engine and the rendering logic in just 8 rules! This massive compression ratio illustrates a profound point: when we truly understand a system, we don&rsquo;t need to store its behavior - we can store its rules and regenerate any behavior we want. This is exactly how human intelligence works: we don&rsquo;t memorize every position or pixel of every object we&rsquo;ve ever seen moving - we learn the intuitive laws of physics and can use them to predict and understand any motion.</p><a href=#the-connection-to-intelligence><h2 id=the-connection-to-intelligence><span class=hanchor arialabel=Anchor># </span>The Connection to Intelligence</h2></a><p>The relationship between compression and intelligence becomes clear when we look at our progression from simple sequences to complex systems. In each case, better compression came from better understanding (&ldquo;modelling&rdquo;) of the dynamics of the system:</p><ol><li>For Fibonacci, understanding the recursive relationship led to 189.21x compression</li><li>For the English sentences, recognizing sentence structure led to 22.93x compression (limited by English&rsquo;s context sensitivity)</li><li>For Sanskrit, PƒÅ·πáini&rsquo;s grammar achieved remarkable compression of an entire language with just ~4,000 rules (~5000:1 compression ratio)</li><li>For Pong, applying PƒÅ·πáini&rsquo;s principles to game physics led to 476,671.45x compression</li></ol><p>This progression - from numbers to language to video games - shows how the same fundamental principles of finding minimal generative descriptions apply across domains. This is why compression can be seen as a measure of intelligence: the better we understand a system, the more efficiently we can describe it.</p><p>In machine learning terms, this is closely related to the concept of &ldquo;minimum description length&rdquo; (MDL) principle, which states that the best model for a dataset is the one that minimizes the size of the model (our grammar rules) and maximizes the size of the data it explains (our inputs)</p><p>This principle is formalized by Ray Solomonoff in his theory of universal inductive inference.</p><blockquote><p>&ldquo;If the universe is generated by an algorithm, then observations of that universe, encoded as a dataset, are best predicted by the smallest executable archive of that dataset&rdquo;</p></blockquote><p>The connection to Solomonoff induction helps explain why PƒÅ·πáini&rsquo;s grammar has remained useful for over two millennia: by finding the shortest possible rule set that could generate Sanskrit, he wasn&rsquo;t just being clever with compression - he was discovering the true underlying structure of the language. Finding the most compressed representation of data (like PƒÅ·πáini&rsquo;s grammar rules) isn&rsquo;t just an efficiency trick - it&rsquo;s mathematically optimal for prediction and understanding.</p><p>This connection between compression and understanding has profound implications:</p><p><strong>Learning</strong> is finding better, shorter abstract grammars for observed data.</p><p><strong>Intelligence</strong> can be measured by ability to find compact descriptions in the fewest observations (e.g. by looking at the least number of Fibonacci numbers).</p><p><strong>Understanding</strong> means finding the true generative process that produces past and future observations.</p><p>When a child learns how to catch a ball, they&rsquo;re not memorizing every position of the ball they&rsquo;ve seen - they&rsquo;re <em>discovering</em> the grammar of projectile motion, that they can apply to any object hurled towards them. When we understand language, we don&rsquo;t memorize every possible sentence - we learn the rules that generate valid ones. When we play chess, we don&rsquo;t memorize every possible board position - we discover the rules of the game, and even discover new high-level rules that the original game designer hadn&rsquo;t thought of - like the <em>Queen&rsquo;s Gambit</em> opening move. When PƒÅ·πáini created his grammar, he wasn&rsquo;t just documenting Sanskrit - he was discovering a fundamental approach to understanding that we can apply to everything from ancient languages to modern video games.</p><p>Indeed, this is what we see with our code examples above and with what PƒÅ·πáini&rsquo;s astonishing feat of compression. His work isn&rsquo;t just limited to modelling the spoken linguistic reality of the past - but could well be about discovering a universal principle of intelligence that will hold the key to building powerful thinking machines of the future.</p><blockquote><p>&ldquo;Riemann invented his geometries before Einstein had a use for them; the physics of our universe is not that complicated in an absolute sense. A Bayesian superintelligence, hooked up to a webcam, would invent General Relativity as a hypothesis‚Äîperhaps not the dominant hypothesis, compared to Newtonian mechanics, but still a hypothesis under direct consideration‚Äîby the time it had seen the third frame of a falling apple. It might guess it from the first frame, if it saw the statics of a bent blade of grass.&rdquo; - E. Yudkowsky</p></blockquote><a href=#references><h2 id=references><span class=hanchor arialabel=Anchor># </span>References</h2></a><p>[1]
<a href="https://www.youtube.com/watch?v=dO4TPJkeaaU" rel=noopener>Youtube video</a>, Compression for AGI, Jack Rae, Stanford MLSys, ex-OpenAI, 2023</p><p>[2]
<a href="https://www.youtube.com/playlist?list=PLsAPTmdVuspykLNnjs1_zQKRMqRRfDr2R" rel=noopener>Youtube Playlist</a>, PƒÅ·πáini Lecture Series, Dr. Saroja Bhate, Bangalore International Center, 2023</p><p>[3] The <em>A·π£·π≠ƒÅdhyƒÅyƒ´</em> achieves a remarkable compression ratio of at least 5000:1, condensing the rules that can generate over 10,000 hours of attested Sanskrit literature (including the ~20,000 verses of the four Vedas, along with the 100,000 verses of the Mahabharata, 24,000 verses of the Ramayana, 400,000 verses of the Puranas, and hundreds of thousands of verses across texts, philosophical shastras, and classical poetry) into just 2 hours of precisely formulated rules.</p><p>[4] PƒÅ·πáini: Catching the Ocean in a Cow&rsquo;s Hoofprint, Vikram Chandra, 2019
<a href=https://blog.granthika.co/panini/ rel=noopener>blog.granthika.co/panini/</a>. Brilliant reading on the topic.
<a href=https://x.com/sibeshkar/status/1889311803907227839 rel=noopener>Excerpt</a></p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/ data-ctx="the PƒÅ·πáinian approach to compression" data-src=/ class=internal-link>üëæ skar</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://sibeshkar.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Sibesh Kar using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, ¬© 2025</p><ul><li><a href=https://sibeshkar.github.io/>Home</a></li><li><a href=https://twitter.com/sibeshkar>Twitter</a></li></ul></footer></div></div></body></html>
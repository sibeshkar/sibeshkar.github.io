<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="&ldquo;The simplest of several competing explanations is likely to be the correct one&rdquo; - Occam&rsquo;s Razor
 Intelligence as compression Let&rsquo;s examine a modified version of Searle&rsquo;s Chinese room experiment."><meta property="og:title" content="The PƒÅ·πáinian Approach to Compression"><meta property="og:description" content="&ldquo;The simplest of several competing explanations is likely to be the correct one&rdquo; - Occam&rsquo;s Razor
 Intelligence as compression Let&rsquo;s examine a modified version of Searle&rsquo;s Chinese room experiment."><meta property="og:type" content="website"><meta property="og:image" content="https://sibeshkar.github.io/icon.png"><meta property="og:url" content="https://sibeshkar.github.io/notes/panini_mid_old/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="The PƒÅ·πáinian Approach to Compression"><meta name=twitter:description content="&ldquo;The simplest of several competing explanations is likely to be the correct one&rdquo; - Occam&rsquo;s Razor
 Intelligence as compression Let&rsquo;s examine a modified version of Searle&rsquo;s Chinese room experiment."><meta name=twitter:image content="https://sibeshkar.github.io/icon.png"><meta name=twitter:site content="sibeshkar"><title>The PƒÅ·πáinian Approach to Compression</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://sibeshkar.github.io//icon.png><link href=https://sibeshkar.github.io/styles.80333fa2099c0bee674efa435fde378c.min.css rel=stylesheet><link href=https://sibeshkar.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://sibeshkar.github.io/js/darkmode.57cc7b5e8e492d275b93efd99423df30.min.js></script>
<script src=https://sibeshkar.github.io/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://sibeshkar.github.io/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://sibeshkar.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://sibeshkar.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://sibeshkar.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://sibeshkar.github.io/",fetchData=Promise.all([fetch("https://sibeshkar.github.io/indices/linkIndex.8c5cafe27a13e3618180c8686fb29358.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://sibeshkar.github.io/indices/contentIndex.efceedee9587dff1114458d146812b73.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://sibeshkar.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://sibeshkar.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'‚Äô':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/sibeshkar.github.io\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=sibeshkar.github.io src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://sibeshkar.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://sibeshkar.github.io/>üëæ skar</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>The PƒÅ·πáinian Approach to Compression</h1><p class=meta>Last updated
Feb 14, 2025
<a href=https://github.com/sibeshkar/notes/panini_mid_old.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#intelligence-as-compression>Intelligence as compression</a></li></ol><ol><li><a href=#the-building-blocks>The Building Blocks</a></li><li><a href=#approach-1-naive-grammar---simple-memorization>Approach 1: Naive Grammar - Simple Memorization</a></li><li><a href=#approach-2-pattern-recognition---seeing-relationships>Approach 2: Pattern Recognition - Seeing Relationships</a></li><li><a href=#approach-3-full-abstraction---the-cognitive-leap>Approach 3: Full Abstraction - The Cognitive Leap</a></li><li><a href=#generating-the-sequence>Generating the Sequence</a></li><li><a href=#from-numbers-to-language>From Numbers to Language</a><ol><li><a href=#naive-grammar-store-each-sentence>Naive Grammar (Store Each Sentence):</a></li><li><a href=#pattern-recognition-find-common-structure>Pattern Recognition (Find Common Structure):</a></li><li><a href=#full-abstraction-separate-first-and-second-items>Full Abstraction (Separate First and Second Items):</a></li><li><a href=#the-challenge-of-english-grammar>The Challenge of English Grammar</a></li><li><a href=#sanskrit-a-more-compressible-language>Sanskrit: A More Compressible Language</a></li><li><a href=#sanskrit-examples-paninis-method-in-action>Sanskrit Examples: Panini&rsquo;s Method in Action</a></li></ol></li><li><a href=#from-numbers-to-panini-the-first-computational-grammarian>From Numbers to Panini: The First Computational Grammarian</a><ol><li><a href=#how-panini-might-have-done-it>How Panini Might Have Done It</a></li><li><a href=#the-first-compression-as-intelligence>The First &ldquo;Compression as Intelligence&rdquo;</a></li><li><a href=#from-ancient-grammar-to-modern-systems>From Ancient Grammar to Modern Systems</a></li></ol></li><li><a href=#extending-to-state-machines-the-case-of-pong>Extending to State Machines: The Case of Pong</a></li><li><a href=#the-connection-to-intelligence>The Connection to Intelligence</a></li><li><a href=#why-this-matters>Why This Matters</a></li><li><a href=#references>References</a></li></ol></nav></details></aside><blockquote><p>&ldquo;The simplest of several competing explanations is likely to be the correct one&rdquo; - Occam&rsquo;s Razor</p></blockquote><a href=#intelligence-as-compression><h2 id=intelligence-as-compression><span class=hanchor arialabel=Anchor># </span>Intelligence as compression</h2></a><p>Let&rsquo;s examine a modified version of Searle&rsquo;s Chinese room experiment. Suppose we have 5.6TB of text data, ethically scraped from the internet, broken into word pairs (2-grams) stored in a lookup table. When asked to complete &ldquo;I was going to wear a&mldr;&rdquo;, it might meaninglessly output &ldquo;a lot&rdquo; because &ldquo;a lot&rdquo; appears more frequently than &ldquo;a shirt&rdquo; or &ldquo;a skirt&rdquo;. A 3-gram model, using two words of context, improves accuracy but still fails in cases like &ldquo;It&rsquo;s raining outside, wear a&mldr;&rdquo;. Both are examples of generative models: they predict the statistically-most-likely next word based on patterns in the data.</p><p>Large Language Models (LLMs) like DeepSeek, GPT, or Claude are more sophisticated versions of such generative models. They use thousands of tokens of context and the &lsquo;attention&rsquo; mechanism to focus on relevant parts of the input to &lsquo;query&rsquo; with. They&rsquo;re not just storing a memorized table of what comes after what, but using compute to extract and store a hiearchy of reusable chunks of information in it&rsquo;s layers. A result is that the weights of the Llama-65B model occupy around 365GB on disk, down from the 5.6TB it&rsquo;s trained on (a 14x compression)[1]. We can see that generalization ability and data efficiency are equivalent: generalization comes from squeezing every bit of information out of your datapoints, understanding all correlations and causations, and connecting all the dots. &ldquo;Squeezing every bit of information&rdquo; is meant literally: generalization is the very direct result of compression.</p><p>Yet, LLMs are still many orders-of-magnitude less data-efficient than humans. Lee Sedol, a top Go player, played around 10,000 games in his lifetime, while DeepMind&rsquo;s bot AlphaGo required 30 million games to match him. If Sedol had played 30 million games, how skilled would he be? What would a human who has absorbed all of human knowledge look like? How does the human generative model compress information so effectively? The answer to these question is the key to building machines that think, learn, adapt to tasks like (or better than) humans do, i.e. general machine intelligence.</p><p>But it&rsquo;s hard to run this experiment because most humans have seen orders of magnitude less data in their lifetimes, and it&rsquo;s hard to manually inspect human priors. Or so I thought, until I attended the lecture series[2] by Dr. Saroja Bhate at Bangalore International Centre, on PƒÅ·πáini (pronounced &ldquo;pah-nee-nee&rdquo;), the ancient Sanskrit grammarian. Over 2300 years ago, before the advent of computers or formal logic, PƒÅ·πáini sat down and methodically reduced all of human knowledge, then floating around in spoken Vedic Sanskrit, into a generative grammar of exactly 3,995 <em>s≈´tras</em>, or rewrite rules - recorded in his magnum opus, the <em>A·π£·π≠ƒÅdhyƒÅyƒ´</em>. These rules have remained unchanged ever since.</p><p>There is a small pool of postdoctoral Sanskrit scholars who are fortunate to understand the full magnitude of PƒÅ·πáini&rsquo;s achievement, but I will try to do some justice to it. Faced with a large corpus of spoken Vedic and contemporary Sanskrit, many thousands of hours of audio signals collected without any substrate to record with or automated tooling to work with, PƒÅ·πáini, over 12 years, found abstracted atoms of meaning that when combined with a set of dynamic rules and meta-rules formed a generative grammar, a deterministic state machine that could be used to re-synthesize the original audio corpus - and be recited in just 2 hours (an astonishing compression ratio of atleast ~5000:1)[3].</p><p>How is PƒÅ·πáini&rsquo;s ~4000 rule set a compressed generative model like one would understand an LLM to be? Imagine prompting an LLM like ChatGPT with an empty prompt, and letting it run for a few paragraphs. If you did this a trillion times, with slightly different temperature settings, you would eventually recover a slightly morphed version of the entire corpus it was trained on. &lsquo;Model distillation&rsquo; is the industry term for this common practice, used to copy parts of another LLM&rsquo;s training set. In a similar manner, if you were to run the state machine described in the <em>A·π£·π≠ƒÅdhyƒÅyƒ´</em> a billion times with random inputs, you would eventually recover all the Vedic hymns, mantras, and Brahmanas it compresses, include the different variations of spoken Sanskrit. Of course, just like you guide an LLM&rsquo;s output by including an input prompt, you would need to guide the state machine in the <em>A·π£·π≠ƒÅdhyƒÅyƒ´</em> to generate the <em>kind</em> of sentences you wanted. But the complexity of the original source remains contained in the abstracted, highly compressed rule set.</p><blockquote><p>&ldquo;If the universe is generated by an algorithm, then observations of that universe, encoded as a dataset, are best predicted by the smallest executable archive of that dataset&rdquo; - Ray Solomonoff, inventor of algorithmic probability</p></blockquote><p>PƒÅ·πáini gives the formation of every inflected, compounded, or derived word, with an exact statement of the sound-variations (including accent) and of the meaning. His foresight in designing these rules means they have stood the test of time - not only expressive enough to explain the knowledge of the past at the time, but also to generalize to phrases and sentences in the future since then. His work is the first formal system known to man, doing to linguistic reality what Euclid would go on to do later for geometry, but it would be no overstatement to call it the most impressive human act of knowledge compression till date. It is the only example we have of true optimal
<a href=https://en.m.wikipedia.org/wiki/Solomonoff%27s_theory_of_inductive_inference rel=noopener>Solomonoff induction</a>, finding the shortest executable archive of a dataset, as evidenced by it&rsquo;s durability over time.</p><p>Of course, PƒÅ·πáini was working with Sanskrit, whose underlying structure makes it less context-sensitive than English and more amenable to such decomposition. But for the sake of comparison, his methods if automated and applied to the
<a href=http://prize.hutter1.net/ rel=noopener>Hutter compression prize</a> dataset could compress 1GB of Wikipedia data to a few kilobytes (down from the current record of 110MB as of Feb 2025). A digital superintelligence in action, would very much employ what could be called &ldquo;PƒÅ·πáini&rsquo;s Razor&rdquo; - applying the dual techniques of abstraction and economy ruthlessly to thousands of noisy signals of various forms and fidelity, reducing them by many orders of magnitude into succinct set of formal predicates - deriving an explanation unchanging in time. Like breaking down a house into basic Lego-like blocks and then building a new house from it back gain, a machine like this could then combine these discovered reusable concepts on the fly using abstracted transformation rules to generalize to any unknown.</p><blockquote><p>&ldquo;The descriptive grammar of Sanskrit which PƒÅ·πáini brought to it&rsquo;s highest perfection is one of the greatest monuments of human intelligence&rdquo; - L. Bloomfield, father of American distributionalism</p></blockquote><p>It&rsquo;s worth examining the implications of this. To build powerful thinking machines of the future that can compress information and generalize better than humans do, we must dig up and study in great detail the forgotten relic that is PƒÅ·πáini&rsquo;s Razor.
Let&rsquo;s examine this idea in detail through concrete examples, starting with something simple and building up to more complex systems.</p><a href=#understanding-generative-grammars-through-compression><h1 id=understanding-generative-grammars-through-compression><span class=hanchor arialabel=Anchor># </span>Understanding Generative Grammars Through Compression</h1></a><p>Disclaimer : I have no formal training in Sanskrit, and the following is merely a programmer&rsquo;s attempt to reverse-engineer PƒÅ·πáini&rsquo;s methods of compression. This is largely a guide for programmers, so we dive into code right away. Let&rsquo;s first look at how generative grammars compress information. All mistakes are mine.</p><p>This is largely a guide for programmers, so we dive into code right away. Let&rsquo;s first look at how generative grammars compress information.</p><p>Imagine you&rsquo;re trying to send the first 100 Fibonacci numbers to a friend. The naive approach would be to simply transmit these numbers directly. Let&rsquo;s see just how big this sequence gets:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>generate_fibonacci</span><span class=p>(</span><span class=n>n</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Generate first n Fibonacci numbers.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>sequence</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>sequence</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>sequence</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>sequence</span><span class=p>[</span><span class=o>-</span><span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sequence</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>fib_sequence</span> <span class=o>=</span> <span class=n>generate_fibonacci</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;First 100 Fibonacci numbers:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;, &#34;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=nb>str</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>fib_sequence</span><span class=p>[:</span><span class=mi>10</span><span class=p>])</span> <span class=o>+</span> <span class=s2>&#34;...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;100th Fibonacci number: </span><span class=si>{</span><span class=n>fib_sequence</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>direct_bits</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>math</span><span class=o>.</span><span class=n>ceil</span><span class=p>(</span><span class=n>math</span><span class=o>.</span><span class=n>log2</span><span class=p>(</span><span class=n>x</span><span class=p>))</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>fib_sequence</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>Direct storage needs </span><span class=si>{</span><span class=n>direct_bits</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bits&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>First 100 Fibonacci numbers:
</span></span><span class=line><span class=cl>1, 1, 2, 3, 5, 8, 13, 21, 34, 55...
</span></span><span class=line><span class=cl>100th Fibonacci number: 354,224,848,179,261,915,075
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Direct storage needs 2,649 bits
</span></span></code></pre></td></tr></table></div></div><p>That&rsquo;s a lot of information! The numbers get very large very quickly - the 100th Fibonacci number is a 21-digit number. Let&rsquo;s see how different approaches to compression handle this much larger sequence.</p><a href=#the-building-blocks><h2 id=the-building-blocks><span class=hanchor arialabel=Anchor># </span>The Building Blocks</h2></a><p>We&rsquo;ll use two main classes to explore this idea:</p><ul><li><code>Rule</code>: Represents a production rule in our grammar, like &ldquo;S -> A B&rdquo; meaning &ldquo;S can be replaced with A followed by B&rdquo;</li><li><code>Grammar</code>: A collection of rules that can generate patterns, with methods to calculate how many bits we need to store it</li></ul><p>You can find the implementation details in
<a rel=noopener class="internal-link broken" data-src=/code/grammar.py><code>grammar.py</code></a>.</p><a href=#approach-1-naive-grammar---simple-memorization><h2 id=approach-1-naive-grammar---simple-memorization><span class=hanchor arialabel=Anchor># </span>Approach 1: Naive Grammar - Simple Memorization</h2></a><p>Let&rsquo;s start with the most straightforward approach - just writing down what we see:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Create a rule for each Fibonacci number</span>
</span></span><span class=line><span class=cl><span class=n>naive_rules</span> <span class=o>=</span> <span class=p>[</span><span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;F1&#39;</span><span class=p>])]</span> <span class=o>+</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;F</span><span class=si>{</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=p>[</span><span class=nb>str</span><span class=p>(</span><span class=n>num</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>num</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>fib_sequence</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>naive_grammar</span> <span class=o>=</span> <span class=n>Grammar</span><span class=p>(</span><span class=n>naive_rules</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>naive_bits</span> <span class=o>=</span> <span class=n>naive_grammar</span><span class=o>.</span><span class=n>description_length</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Naive grammar needs </span><span class=si>{</span><span class=n>naive_bits</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bits&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Compression ratio: </span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>naive_bits</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2>x&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Naive grammar needs 892 bits
</span></span><span class=line><span class=cl>Compression ratio: 2.97x
</span></span></code></pre></td></tr></table></div></div><p>This represents the most basic level of pattern recognition:</p><ul><li>‚úì Noticing that numbers can be labeled (F1, F2, etc.)</li><li>‚úì Understanding sequence order</li><li>‚úó No understanding of relationships between numbers</li><li>‚úó No recognition of the underlying pattern</li></ul><p>It&rsquo;s like a student who memorizes &ldquo;1, 1, 2, 3, 5, 8&mldr;&rdquo; without understanding why these numbers appear in this order. They achieve some compression just by being organized, but they&rsquo;re still essentially memorizing.</p><a href=#approach-2-pattern-recognition---seeing-relationships><h2 id=approach-2-pattern-recognition---seeing-relationships><span class=hanchor arialabel=Anchor># </span>Approach 2: Pattern Recognition - Seeing Relationships</h2></a><p>Now we start to notice relationships between numbers. This requires more sophisticated observation:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>pattern_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=s1>&#39;N1&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;N1&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;1&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl><span class=p>]</span> <span class=o>+</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;N</span><span class=si>{</span><span class=n>fib</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>,</span> <span class=p>[</span><span class=nb>str</span><span class=p>(</span><span class=n>fib</span><span class=p>)])</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>fib</span> <span class=ow>in</span> <span class=nb>sorted</span><span class=p>(</span><span class=nb>set</span><span class=p>(</span><span class=n>fib_sequence</span><span class=p>[:</span><span class=mi>20</span><span class=p>]))</span>  <span class=c1># First 20 unique numbers</span>
</span></span><span class=line><span class=cl><span class=p>]</span> <span class=o>+</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;N1&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;N1&#39;</span><span class=p>,</span> <span class=s1>&#39;+&#39;</span><span class=p>,</span> <span class=s1>&#39;N1&#39;</span><span class=p>]),</span>  <span class=c1># 1 + 1 = 2</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;N2&#39;</span><span class=p>,</span> <span class=s1>&#39;+&#39;</span><span class=p>,</span> <span class=s1>&#39;N3&#39;</span><span class=p>]),</span>  <span class=c1># 2 + 3 = 5</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;N3&#39;</span><span class=p>,</span> <span class=s1>&#39;+&#39;</span><span class=p>,</span> <span class=s1>&#39;N5&#39;</span><span class=p>]),</span>  <span class=c1># 3 + 5 = 8</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;N5&#39;</span><span class=p>,</span> <span class=s1>&#39;+&#39;</span><span class=p>,</span> <span class=s1>&#39;N8&#39;</span><span class=p>]),</span>  <span class=c1># 5 + 8 = 13</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>pattern_grammar</span> <span class=o>=</span> <span class=n>Grammar</span><span class=p>(</span><span class=n>pattern_rules</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>pattern_bits</span> <span class=o>=</span> <span class=n>pattern_grammar</span><span class=o>.</span><span class=n>description_length</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Pattern grammar needs </span><span class=si>{</span><span class=n>pattern_bits</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bits&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Compression ratio: </span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>pattern_bits</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2>x&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Pattern grammar needs 428 bits
</span></span><span class=line><span class=cl>Compression ratio: 6.19x
</span></span></code></pre></td></tr></table></div></div><p>This represents an intermediate level of understanding:</p><ul><li>‚úì Recognition that numbers are related through addition</li><li>‚úì Ability to see specific instances of the pattern</li><li>‚úó Still manually writing out each addition step</li><li>‚úó No recognition of the recursive nature</li><li>‚úó Can&rsquo;t generate numbers beyond what&rsquo;s explicitly coded</li></ul><p>It&rsquo;s like a student who realizes &ldquo;Oh, I can get each number by adding specific previous numbers!&rdquo; They&rsquo;re starting to see relationships, but they&rsquo;re still writing out each step manually. They might even make a table:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1 + 1 = 2
</span></span><span class=line><span class=cl>2 + 3 = 5
</span></span><span class=line><span class=cl>3 + 5 = 8
</span></span></code></pre></td></tr></table></div></div><p>This is better than memorization, but they haven&rsquo;t yet had their &ldquo;aha!&rdquo; moment.</p><a href=#approach-3-full-abstraction---the-cognitive-leap><h2 id=approach-3-full-abstraction---the-cognitive-leap><span class=hanchor arialabel=Anchor># </span>Approach 3: Full Abstraction - The Cognitive Leap</h2></a><p>Finally, we make the cognitive leap to understand the deep structure:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>abstract_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=s1>&#39;1&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;1&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;F&#39;</span><span class=p>,</span> <span class=s1>&#39;+&#39;</span><span class=p>,</span> <span class=s1>&#39;F_prev&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>abstract_grammar</span> <span class=o>=</span> <span class=n>Grammar</span><span class=p>(</span><span class=n>abstract_rules</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>abstract_bits</span> <span class=o>=</span> <span class=n>abstract_grammar</span><span class=o>.</span><span class=n>description_length</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Abstract grammar needs </span><span class=si>{</span><span class=n>abstract_bits</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bits&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Compression ratio: </span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>abstract_bits</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2>x&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Abstract grammar needs 14 bits
</span></span><span class=line><span class=cl>Compression ratio: 189.21x
</span></span></code></pre></td></tr></table></div></div><p>This represents the highest level of understanding, requiring several cognitive breakthroughs:</p><ul><li>‚úì Recognition that each number depends on the previous TWO numbers</li><li>‚úì Understanding that this single relationship explains EVERY number</li><li>‚úì Grasping that you don&rsquo;t need to store the numbers themselves</li><li>‚úì Realizing the pattern is recursive and self-contained</li><li>‚úì Understanding that this works for ANY length sequence</li></ul><p>The cognitive steps to reach this understanding typically involve:</p><ol><li>Noticing that you&rsquo;re always adding two numbers</li><li>Realizing those two numbers are always the previous ones</li><li>The key insight: this ONE rule explains EVERYTHING</li><li>Understanding that with just this rule and a starting point, you can generate the entire sequence</li></ol><p>It&rsquo;s like the student who suddenly exclaims &ldquo;Wait&mldr; we&rsquo;re ALWAYS just adding the last two numbers! That&rsquo;s all we need to know!&rdquo; This is the moment of true understanding, where the pattern becomes crystal clear and beautifully simple.</p><a href=#generating-the-sequence><h2 id=generating-the-sequence><span class=hanchor arialabel=Anchor># </span>Generating the Sequence</h2></a><p>The beauty of this abstract grammar is that it&rsquo;s not just for compression - we can use it to regenerate the original sequence or extend it to any length we want:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>generate_fibonacci</span><span class=p>(</span><span class=n>n</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Generate first n Fibonacci numbers using our grammar rules.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>sequence</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>]</span>  <span class=c1># Initial state from our grammar&#39;s rules</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>sequence</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>sequence</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>sequence</span><span class=p>[</span><span class=o>-</span><span class=mi>2</span><span class=p>])</span>  <span class=c1># F -&gt; F + F_prev rule</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sequence</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Test the generator</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Regenerating our sequence:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>generate_fibonacci</span><span class=p>(</span><span class=mi>10</span><span class=p>))</span>  <span class=c1># First 10 numbers</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>Extending beyond what we originally stored:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>generate_fibonacci</span><span class=p>(</span><span class=mi>15</span><span class=p>))</span>  <span class=c1># First 15 numbers</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Regenerating our sequence:
</span></span><span class=line><span class=cl>[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Extending beyond what we originally stored:
</span></span><span class=line><span class=cl>[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]
</span></span></code></pre></td></tr></table></div></div><p>This demonstrates the true power of understanding the generative process: with just 14 bits of grammar rules, we can:</p><ol><li>Reproduce the original sequence exactly</li><li>Generate any Fibonacci number we want</li><li>Extend the sequence infinitely</li></ol><p>The massive improvement in compression ratio (189.21x vs 2.97x) reflects this deep understanding. We&rsquo;ve gone from:</p><ul><li>Memorizing 100 numbers (naive) ‚Üí</li><li>Understanding specific additions (pattern) ‚Üí</li><li>Grasping the universal rule (abstract)</li></ul><p>This progression mirrors how humans learn: from memorization, to pattern recognition, to true understanding. The fact that better understanding leads to better compression isn&rsquo;t just a mathematical curiosity - it&rsquo;s a fundamental principle of how we make sense of the world.</p><p>Let&rsquo;s visualize these compression ratios:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>Compression Comparison:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;=&#34;</span> <span class=o>*</span> <span class=mi>50</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Direct storage:     </span><span class=si>{</span><span class=n>direct_bits</span><span class=si>:</span><span class=s2>6,</span><span class=si>}</span><span class=s2> bits (baseline)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Naive grammar:      </span><span class=si>{</span><span class=n>naive_bits</span><span class=si>:</span><span class=s2>6,</span><span class=si>}</span><span class=s2> bits (</span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>naive_bits</span><span class=si>:</span><span class=s2>6.2f</span><span class=si>}</span><span class=s2>x better)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Pattern grammar:    </span><span class=si>{</span><span class=n>pattern_bits</span><span class=si>:</span><span class=s2>6,</span><span class=si>}</span><span class=s2> bits (</span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>pattern_bits</span><span class=si>:</span><span class=s2>6.2f</span><span class=si>}</span><span class=s2>x better)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Abstract grammar:   </span><span class=si>{</span><span class=n>abstract_bits</span><span class=si>:</span><span class=s2>6,</span><span class=si>}</span><span class=s2> bits (</span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>abstract_bits</span><span class=si>:</span><span class=s2>6.2f</span><span class=si>}</span><span class=s2>x better)&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Compression Comparison:
</span></span><span class=line><span class=cl>==================================================
</span></span><span class=line><span class=cl>Direct storage:      2,649 bits (baseline)
</span></span><span class=line><span class=cl>Naive grammar:         892 bits (  2.97x better)
</span></span><span class=line><span class=cl>Pattern grammar:       428 bits (  6.19x better)
</span></span><span class=line><span class=cl>Abstract grammar:       14 bits (189.21x better)
</span></span></code></pre></td></tr></table></div></div><p>This dramatic improvement shows the true power of finding the underlying generative process. The more data we have, the more valuable it becomes to understand the true pattern rather than just storing or partially compressing the output.</p><a href=#from-numbers-to-language><h2 id=from-numbers-to-language><span class=hanchor arialabel=Anchor># </span>From Numbers to Language</h2></a><p>Let&rsquo;s apply the same thinking to language patterns. Here&rsquo;s a set of similar sentences:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>sentences</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;I like cats and dogs&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;I like books and music&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;I like coffee and tea&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;I like movies and games&#34;</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>direct_bits</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=o>*</span> <span class=mi>8</span> <span class=k>for</span> <span class=n>s</span> <span class=ow>in</span> <span class=n>sentences</span><span class=p>)</span>  <span class=c1># 8 bits per char</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Direct storage needs </span><span class=si>{</span><span class=n>direct_bits</span><span class=si>}</span><span class=s2> bits&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Direct storage needs 688 bits
</span></span></code></pre></td></tr></table></div></div><p>That&rsquo;s a lot of bits! Let&rsquo;s try our different approaches:</p><a href=#naive-grammar-store-each-sentence><h3 id=naive-grammar-store-each-sentence><span class=hanchor arialabel=Anchor># </span>Naive Grammar (Store Each Sentence):</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>naive_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;I&#39;</span><span class=p>,</span> <span class=s1>&#39;like&#39;</span><span class=p>,</span> <span class=s1>&#39;cats&#39;</span><span class=p>,</span> <span class=s1>&#39;and&#39;</span><span class=p>,</span> <span class=s1>&#39;dogs&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;I&#39;</span><span class=p>,</span> <span class=s1>&#39;like&#39;</span><span class=p>,</span> <span class=s1>&#39;books&#39;</span><span class=p>,</span> <span class=s1>&#39;and&#39;</span><span class=p>,</span> <span class=s1>&#39;music&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;I&#39;</span><span class=p>,</span> <span class=s1>&#39;like&#39;</span><span class=p>,</span> <span class=s1>&#39;coffee&#39;</span><span class=p>,</span> <span class=s1>&#39;and&#39;</span><span class=p>,</span> <span class=s1>&#39;tea&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;I&#39;</span><span class=p>,</span> <span class=s1>&#39;like&#39;</span><span class=p>,</span> <span class=s1>&#39;movies&#39;</span><span class=p>,</span> <span class=s1>&#39;and&#39;</span><span class=p>,</span> <span class=s1>&#39;games&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>naive_grammar</span> <span class=o>=</span> <span class=n>Grammar</span><span class=p>(</span><span class=n>naive_rules</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>naive_bits</span> <span class=o>=</span> <span class=n>naive_grammar</span><span class=o>.</span><span class=n>description_length</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Naive grammar needs </span><span class=si>{</span><span class=n>naive_bits</span><span class=si>}</span><span class=s2> bits (compression ratio: </span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>naive_bits</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2>x)&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Naive grammar needs 63 bits (compression ratio: 10.92x)
</span></span></code></pre></td></tr></table></div></div><p>Just by recognizing words as reusable symbols, we get almost 11x compression!</p><a href=#pattern-recognition-find-common-structure><h3 id=pattern-recognition-find-common-structure><span class=hanchor arialabel=Anchor># </span>Pattern Recognition (Find Common Structure):</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>pattern_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;I&#39;</span><span class=p>,</span> <span class=s1>&#39;like&#39;</span><span class=p>,</span> <span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=s1>&#39;and&#39;</span><span class=p>,</span> <span class=s1>&#39;THING&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;cats&#39;</span><span class=p>]),</span> <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;dogs&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;books&#39;</span><span class=p>]),</span> <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;music&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;coffee&#39;</span><span class=p>]),</span> <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;tea&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;movies&#39;</span><span class=p>]),</span> <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;THING&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;games&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>pattern_grammar</span> <span class=o>=</span> <span class=n>Grammar</span><span class=p>(</span><span class=n>pattern_rules</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>pattern_bits</span> <span class=o>=</span> <span class=n>pattern_grammar</span><span class=o>.</span><span class=n>description_length</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Pattern grammar needs </span><span class=si>{</span><span class=n>pattern_bits</span><span class=si>}</span><span class=s2> bits (compression ratio: </span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>pattern_bits</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2>x)&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Pattern grammar needs 30 bits (compression ratio: 22.93x)
</span></span></code></pre></td></tr></table></div></div><p>By recognizing that we can reuse the pattern &ldquo;I like X and Y&rdquo;, we get even better compression!</p><a href=#full-abstraction-separate-first-and-second-items><h3 id=full-abstraction-separate-first-and-second-items><span class=hanchor arialabel=Anchor># </span>Full Abstraction (Separate First and Second Items):</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>abstract_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;I&#39;</span><span class=p>,</span> <span class=s1>&#39;like&#39;</span><span class=p>,</span> <span class=s1>&#39;N1&#39;</span><span class=p>,</span> <span class=s1>&#39;and&#39;</span><span class=p>,</span> <span class=s1>&#39;N2&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;N1&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;cats&#39;</span><span class=p>,</span> <span class=s1>&#39;books&#39;</span><span class=p>,</span> <span class=s1>&#39;coffee&#39;</span><span class=p>,</span> <span class=s1>&#39;movies&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;N2&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;dogs&#39;</span><span class=p>,</span> <span class=s1>&#39;music&#39;</span><span class=p>,</span> <span class=s1>&#39;tea&#39;</span><span class=p>,</span> <span class=s1>&#39;games&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>abstract_grammar</span> <span class=o>=</span> <span class=n>Grammar</span><span class=p>(</span><span class=n>abstract_rules</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>abstract_bits</span> <span class=o>=</span> <span class=n>abstract_grammar</span><span class=o>.</span><span class=n>description_length</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Abstract grammar needs </span><span class=si>{</span><span class=n>abstract_bits</span><span class=si>}</span><span class=s2> bits (compression ratio: </span><span class=si>{</span><span class=n>direct_bits</span><span class=o>/</span><span class=n>abstract_bits</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2>x)&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Abstract grammar needs 39 bits (compression ratio: 17.64x)
</span></span></code></pre></td></tr></table></div></div><p>Interestingly, trying to be too clever (separating first and second items) actually hurts our compression! This is a key insight: the best compression comes from matching the true structure of the data.</p><a href=#the-challenge-of-english-grammar><h3 id=the-challenge-of-english-grammar><span class=hanchor arialabel=Anchor># </span>The Challenge of English Grammar</h3></a><p>However, English presents a challenge for such clean abstractions. Unlike our previous examples, English is a context-sensitive language, which means the interpretation of a word or phrase often depends on its context. For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>context_examples</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;The bank is closed&#34;</span> <span class=p>,</span>           <span class=c1># Financial institution</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;The bank is muddy&#34;</span><span class=p>,</span>            <span class=c1># River bank</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;I bank on your support&#34;</span><span class=p>,</span>       <span class=c1># Rely/depend</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;The plane will bank left&#34;</span>      <span class=c1># Aviation term</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>This context sensitivity means:</p><ol><li>The same word can have different meanings based on surrounding words</li><li>The same grammatical structure can have different interpretations</li><li>Valid combinations depend on semantic meaning, not just syntax</li></ol><p>This limits how much we can compress English using pure grammatical rules. Our compression ratio of 22.93x was possible because we used a very restricted subset of English. In the general case, we would need:</p><ul><li>Semantic context rules</li><li>Word sense disambiguation</li><li>Complex dependency structures</li></ul><p>This is why formal languages (like programming languages) and some natural languages with more rigid structure can achieve better compression ratios.</p><a href=#sanskrit-a-more-compressible-language><h3 id=sanskrit-a-more-compressible-language><span class=hanchor arialabel=Anchor># </span>Sanskrit: A More Compressible Language</h3></a><p>Sanskrit, in contrast, was designed with formal grammar in mind. Its structure is more amenable to rule-based generation because:</p><ol><li>Words are derived from root forms using explicit rules</li><li>Compound words follow clear compositional rules</li><li>Sentence structure has more rigid constraints</li><li>Word meanings are more systematically related to their roots</li></ol><p>This makes Sanskrit more like our Fibonacci sequence - there are clear generative rules that can produce valid constructions.</p><a href=#sanskrit-examples-paninis-method-in-action><h3 id=sanskrit-examples-paninis-method-in-action><span class=hanchor arialabel=Anchor># </span>Sanskrit Examples: Panini&rsquo;s Method in Action</h3></a><p>Let&rsquo;s look at some concrete examples of how Panini&rsquo;s grammar generates Sanskrit words and sentences:</p><ol><li><p><strong>Root-Based Word Generation</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Example: Generating forms of &#34;bh≈´&#34; (to be)</span>
</span></span><span class=line><span class=cl><span class=n>root_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;VERB&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;ROOT&#39;</span><span class=p>,</span> <span class=s1>&#39;SUFFIX&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;ROOT&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;bh≈´&#39;</span><span class=p>]),</span>  <span class=c1># &#34;to be&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;SUFFIX&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;ami&#39;</span><span class=p>]),</span>  <span class=c1># 1st person present</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;SUFFIX&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;asi&#39;</span><span class=p>]),</span>  <span class=c1># 2nd person present</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;SUFFIX&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;ati&#39;</span><span class=p>])</span>   <span class=c1># 3rd person present</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>This generates:</p><ul><li>bhavƒÅmi (I am)</li><li>bhavasi (you are)</li><li>bhavati (he/she/it is)</li></ul><p>The transformation bh≈´ ‚Üí bhav is handled by another rule (gu·πáa strengthening), showing how Panini&rsquo;s grammar captures phonological changes systematically.</p></li><li><p><strong>Compound Word Formation</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Example: Generating compound words</span>
</span></span><span class=line><span class=cl><span class=n>compound_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;COMPOUND&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;WORD1&#39;</span><span class=p>,</span> <span class=s1>&#39;WORD2&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;WORD1&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;rƒÅja&#39;</span><span class=p>]),</span>  <span class=c1># king</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;WORD2&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;putra&#39;</span><span class=p>])</span>  <span class=c1># son</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>sandhi_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;SANDHI&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=s1>&#39;a&#39;</span><span class=p>],</span> <span class=p>[</span><span class=s1>&#39;ƒÅ&#39;</span><span class=p>]),</span>  <span class=c1># a + a ‚Üí ƒÅ</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>This generates:</p><ul><li>rƒÅja + putra ‚Üí rƒÅjaputra (king&rsquo;s son)
The rules handle both combination and sound changes (sandhi).</li></ul></li><li><p><strong>Sentence Structure</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Example: Generating active/passive sentences</span>
</span></span><span class=line><span class=cl><span class=n>sentence_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;S&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;NP&#39;</span><span class=p>,</span> <span class=s1>&#39;VP&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;NP&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;devadatta&#39;</span><span class=p>]),</span>  <span class=c1># Devadatta (name)</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;VP&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;odana·πÉ&#39;</span><span class=p>,</span> <span class=s1>&#39;pacati&#39;</span><span class=p>]),</span>  <span class=c1># rice + cooks</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;VP_PASSIVE&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;odana·∏•&#39;</span><span class=p>,</span> <span class=s1>&#39;pacyate&#39;</span><span class=p>])</span>  <span class=c1># rice + is cooked</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>This generates:</p><ul><li>devadatta·∏• odana·πÉ pacati (Devadatta cooks rice)</li><li>odana·∏• pacyate (Rice is cooked)</li></ul></li></ol><p>The power of Panini&rsquo;s system comes from how these rules interact:</p><ol><li><p><strong>Recursive Application</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Example: Complex word formation</span>
</span></span><span class=line><span class=cl><span class=n>derivation_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;WORD&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;ROOT&#39;</span><span class=p>,</span> <span class=s1>&#39;PRIMARY_SUFFIX&#39;</span><span class=p>,</span> <span class=s1>&#39;SECONDARY_SUFFIX&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;ROOT&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;bh≈´&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;PRIMARY_SUFFIX&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;ana&#39;</span><span class=p>]),</span>  <span class=c1># action noun</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;SECONDARY_SUFFIX&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;tva&#39;</span><span class=p>])</span>  <span class=c1># abstract quality</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>This generates:</p><ul><li>bh≈´ ‚Üí bhavana (becoming) ‚Üí bhavanatva (the quality of becoming)</li></ul></li><li><p><strong>Meta-Rules</strong>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Example: Rule ordering</span>
</span></span><span class=line><span class=cl><span class=n>meta_rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;APPLY_ORDER&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;ROOT_RULES&#39;</span><span class=p>,</span> <span class=s1>&#39;SANDHI_RULES&#39;</span><span class=p>,</span> <span class=s1>&#39;ACCENT_RULES&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>    <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;EXCEPTION&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;if_final_position&#39;</span><span class=p>,</span> <span class=s1>&#39;skip_sandhi&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></td></tr></table></div></div><p>These meta-rules ensure correct application order and handle exceptions systematically.</p></li></ol><p>This systematic approach achieves remarkable compression because:</p><ol><li>Each rule can generate many forms (e.g., one verb root rule generates hundreds of conjugations)</li><li>Rules interact to produce complex forms (like compounds and derivatives)</li><li>Meta-rules handle exceptions without needing separate rules for each case</li><li>The system captures both form (phonology) and meaning (semantics)</li></ol><p>For example, from just the root &ldquo;bh≈´&rdquo; and a set of rules, Panini&rsquo;s grammar can generate:</p><ul><li>All conjugated forms (bhavƒÅmi, bhavasi, bhavati, etc.)</li><li>All derived nouns (bhavana, bhƒÅva, bh≈´ti, etc.)</li><li>All compounds (bh≈´loka - world of existence, bh≈´tap≈´rva - having been before, etc.)</li><li>All these forms in different syntactic roles</li></ul><p>This is analogous to our Fibonacci example, where one simple rule (Fn = Fn-1 + Fn-2) generates an infinite sequence. But Panini&rsquo;s grammar goes further, handling multiple interacting patterns simultaneously while maintaining semantic coherence.</p><a href=#from-numbers-to-panini-the-first-computational-grammarian><h2 id=from-numbers-to-panini-the-first-computational-grammarian><span class=hanchor arialabel=Anchor># </span>From Numbers to Panini: The First Computational Grammarian</h2></a><p>After seeing how we derived grammars for the Fibonacci sequence and explored language patterns, let&rsquo;s look at a remarkable historical parallel: Panini&rsquo;s Ashtadhyayi, written around 500 BCE. This ancient work presents Sanskrit grammar as a generative system, much like our examples above.</p><a href=#how-panini-might-have-done-it><h3 id=how-panini-might-have-done-it><span class=hanchor arialabel=Anchor># </span>How Panini Might Have Done It</h3></a><p>Looking at our own process of grammar derivation:</p><ol><li>Start with examples (like our Fibonacci numbers or sentences)</li><li>Look for patterns (like our pattern recognition phase)</li><li>Abstract to rules (like our final grammars)</li></ol><p>Panini likely followed a similar path:</p><ol><li><strong>Data Collection</strong>: Gathered thousands of Sanskrit utterances</li><li><strong>Pattern Recognition</strong>: Identified recurring structures</li><li><strong>Rule Abstraction</strong>: Derived minimal generative rules</li><li><strong>Optimization</strong>: Compressed rules for memorization</li></ol><p>His grammar achieves remarkable compression:</p><ul><li>~4,000 rules can generate all of Sanskrit</li><li>Rules are so concise they fit in ~40 pages</li><li>Can generate millions of valid word forms</li><li>Includes phonological, morphological, and syntactic levels</li></ul><a href=#the-first-compression-as-intelligence><h3 id=the-first-compression-as-intelligence><span class=hanchor arialabel=Anchor># </span>The First &ldquo;Compression as Intelligence&rdquo;</h3></a><p>What makes Panini&rsquo;s work particularly relevant to our discussion is that it demonstrates the same principles we&rsquo;ve discovered:</p><ol><li><p><strong>Cognitive Progression</strong>:</p><ul><li>Like our Fibonacci example progressing from naive to abstract</li><li>From memorizing words to understanding derivation rules</li></ul></li><li><p><strong>Minimal Description</strong>:</p><ul><li>Like our abstract Fibonacci grammar using just 3 rules</li><li>His grammar captures an entire language in ~4,000 rules</li></ul></li><li><p><strong>Generative Power</strong>:</p><ul><li>Like our abstract grammars generating infinite sequences</li><li>His system can generate all valid Sanskrit constructions</li></ul></li></ol><a href=#from-ancient-grammar-to-modern-systems><h3 id=from-ancient-grammar-to-modern-systems><span class=hanchor arialabel=Anchor># </span>From Ancient Grammar to Modern Systems</h3></a><p>While Panini&rsquo;s work on Sanskrit grammar might seem purely academic, his approach to finding minimal generative rules has profound implications for modern complex systems. Consider:</p><ol><li><strong>Pattern Recognition</strong>: Just as Panini identified patterns in language, we can identify patterns in any system</li><li><strong>Rule Abstraction</strong>: His method of finding minimal rules can apply to any complex behavior</li><li><strong>Generative Power</strong>: Like his grammar generating infinite valid sentences, we can generate infinite valid states</li></ol><p>This approach becomes particularly powerful when we apply it to modern systems that seem vastly different from language. Let&rsquo;s see how Panini&rsquo;s principles can help us understand and compress something seemingly unrelated: a video game.</p><a href=#extending-to-state-machines-the-case-of-pong><h2 id=extending-to-state-machines-the-case-of-pong><span class=hanchor arialabel=Anchor># </span>Extending to State Machines: The Case of Pong</h2></a><p>The real power of Panini&rsquo;s compression approach to generative grammars becomes clear when we apply it to modelling more complex systems with real-world state machines - like video games. Just as Panini found that all of Sanskrit could be generated from ~4,000 rules, we&rsquo;ll see how an entire game can be generated from just 8 rules. Let&rsquo;s look at how we could compress a recording of a Pong game:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>PongGrammar</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>rules</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>            <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;GAME&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;INIT&#39;</span><span class=p>,</span> <span class=s1>&#39;LOOP&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>            <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;INIT&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;Ball(center)&#39;</span><span class=p>,</span> <span class=s1>&#39;Paddle1(mid)&#39;</span><span class=p>,</span> <span class=s1>&#39;Paddle2(mid)&#39;</span><span class=p>,</span> <span class=s1>&#39;Score(0,0)&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>            <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;LOOP&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;UPDATE&#39;</span><span class=p>,</span> <span class=s1>&#39;COLLISIONS&#39;</span><span class=p>,</span> <span class=s1>&#39;SCORE&#39;</span><span class=p>,</span> <span class=s1>&#39;LOOP&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>            <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;UPDATE&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;Ball(pos += vel)&#39;</span><span class=p>,</span> <span class=s1>&#39;Paddle1(pos += input1)&#39;</span><span class=p>,</span> <span class=s1>&#39;Paddle2(pos += input2)&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>            <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;COLLISIONS&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;WALL_CHECK&#39;</span><span class=p>,</span> <span class=s1>&#39;PADDLE_CHECK&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>            <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;WALL_CHECK&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;if ball.y &gt; height: ball.vel.y *= -1&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>            <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;PADDLE_CHECK&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;if ball.collides(paddle): ball.vel.x *= -1&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>            <span class=n>Rule</span><span class=p>(</span><span class=s1>&#39;SCORE&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;if ball.x &lt; 0: p2_score++ else if ball.x &gt; width: p1_score++&#39;</span><span class=p>]),</span>
</span></span><span class=line><span class=cl>        <span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>grammar</span> <span class=o>=</span> <span class=n>Grammar</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>rules</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Let&#39;s calculate sizes for a 5-minute game at 60 FPS</span>
</span></span><span class=line><span class=cl><span class=n>frames</span> <span class=o>=</span> <span class=mi>300</span> <span class=o>*</span> <span class=mi>60</span>  <span class=c1># 5 minutes at 60 FPS</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># First, let&#39;s look at a conservative estimate (just storing positions)</span>
</span></span><span class=line><span class=cl><span class=n>pos_frame_size</span> <span class=o>=</span> <span class=p>(</span><span class=mi>4</span> <span class=o>+</span> <span class=mi>4</span> <span class=o>+</span> <span class=mi>8</span><span class=p>)</span>  <span class=c1># 4 bytes each for paddles, 8 for ball position</span>
</span></span><span class=line><span class=cl><span class=n>pos_raw_size</span> <span class=o>=</span> <span class=n>pos_frame_size</span> <span class=o>*</span> <span class=n>frames</span>
</span></span><span class=line><span class=cl><span class=n>grammar_size</span> <span class=o>=</span> <span class=n>pong</span><span class=o>.</span><span class=n>grammar</span><span class=o>.</span><span class=n>description_length</span><span class=p>()</span>  <span class=c1># Rules of the game</span>
</span></span><span class=line><span class=cl><span class=n>input_size</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>frames</span>  <span class=c1># 1 bit per paddle per frame</span>
</span></span><span class=line><span class=cl><span class=n>state_size</span> <span class=o>=</span> <span class=mi>16</span>  <span class=c1># 4 bytes each for ball x,y and two paddle positions</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Conservative Estimate (Position Data Only)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;=========================================&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Raw position data:   </span><span class=si>{</span><span class=n>pos_raw_size</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bytes (</span><span class=si>{</span><span class=n>pos_raw_size</span><span class=o>/</span><span class=mi>1024</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> KB)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Grammar + state:     </span><span class=si>{</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bytes (</span><span class=si>{</span><span class=p>(</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=p>)</span><span class=o>/</span><span class=mi>1024</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> KB)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Compression ratio:   </span><span class=si>{</span><span class=n>pos_raw_size</span><span class=o>/</span><span class=p>(</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=p>)</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2>x&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Now let&#39;s look at the full visual data</span>
</span></span><span class=line><span class=cl><span class=n>frame_height</span> <span class=o>=</span> <span class=mi>210</span>
</span></span><span class=line><span class=cl><span class=n>frame_width</span> <span class=o>=</span> <span class=mi>160</span>
</span></span><span class=line><span class=cl><span class=n>channels</span> <span class=o>=</span> <span class=mi>3</span>  <span class=c1># RGB</span>
</span></span><span class=line><span class=cl><span class=n>pixel_frame_size</span> <span class=o>=</span> <span class=n>frame_height</span> <span class=o>*</span> <span class=n>frame_width</span> <span class=o>*</span> <span class=n>channels</span>  <span class=c1># bytes per frame</span>
</span></span><span class=line><span class=cl><span class=n>pixel_raw_size</span> <span class=o>=</span> <span class=n>pixel_frame_size</span> <span class=o>*</span> <span class=n>frames</span>  <span class=c1># Full video storage</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>Full Visual Data Estimate (Every Pixel)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;=======================================&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Frame dimensions: </span><span class=si>{</span><span class=n>frame_width</span><span class=si>}</span><span class=s2>x</span><span class=si>{</span><span class=n>frame_height</span><span class=si>}</span><span class=s2> pixels (RGB)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Storage requirements:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;- Raw video:        </span><span class=si>{</span><span class=n>pixel_raw_size</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bytes (</span><span class=si>{</span><span class=n>pixel_raw_size</span><span class=o>/</span><span class=mi>1024</span><span class=o>/</span><span class=mi>1024</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> MB)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;- Grammar rules:    </span><span class=si>{</span><span class=n>grammar_size</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bytes&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;- Player inputs:    </span><span class=si>{</span><span class=n>input_size</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bytes&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;- Game state:       </span><span class=si>{</span><span class=n>state_size</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bytes&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;- Total compressed: </span><span class=si>{</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=si>:</span><span class=s2>,</span><span class=si>}</span><span class=s2> bytes (</span><span class=si>{</span><span class=p>(</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=p>)</span><span class=o>/</span><span class=mi>1024</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> KB)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Compression ratio:  </span><span class=si>{</span><span class=n>pixel_raw_size</span><span class=o>/</span><span class=p>(</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=p>)</span><span class=si>:</span><span class=s2>,.2f</span><span class=si>}</span><span class=s2>x&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># To put this in perspective:</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>To store a 5-minute Pong game:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;1. Conservative Approach (Just Positions)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;   - Raw data: </span><span class=si>{</span><span class=n>pos_raw_size</span><span class=o>/</span><span class=mi>1024</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> KB&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;   - Compressed: </span><span class=si>{</span><span class=p>(</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=p>)</span><span class=o>/</span><span class=mi>1024</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> KB&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;   - Ratio: </span><span class=si>{</span><span class=n>pos_raw_size</span><span class=o>/</span><span class=p>(</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=p>)</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2>x better&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>2. Full Visual Approach (Every Pixel)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;   - Raw data: </span><span class=si>{</span><span class=n>pixel_raw_size</span><span class=o>/</span><span class=mi>1024</span><span class=o>/</span><span class=mi>1024</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> MB&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;   - Compressed: </span><span class=si>{</span><span class=p>(</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=p>)</span><span class=o>/</span><span class=mi>1024</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> KB&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;   - Ratio: </span><span class=si>{</span><span class=n>pixel_raw_size</span><span class=o>/</span><span class=p>(</span><span class=n>grammar_size</span> <span class=o>+</span> <span class=n>input_size</span> <span class=o>+</span> <span class=n>state_size</span><span class=p>)</span><span class=si>:</span><span class=s2>,.2f</span><span class=si>}</span><span class=s2>x better&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Conservative Estimate (Position Data Only)
</span></span><span class=line><span class=cl>=========================================
</span></span><span class=line><span class=cl>Raw position data:   1,872,000 bytes (1,828.1 KB)
</span></span><span class=line><span class=cl>Grammar + state:     38,064 bytes (37.2 KB)
</span></span><span class=line><span class=cl>Compression ratio:   49.18x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Full Visual Data Estimate (Every Pixel)
</span></span><span class=line><span class=cl>=======================================
</span></span><span class=line><span class=cl>Frame dimensions: 160x210 pixels (RGB)
</span></span><span class=line><span class=cl>Storage requirements:
</span></span><span class=line><span class=cl>- Raw video:        18,144,000,000 bytes (17,304.7 MB)
</span></span><span class=line><span class=cl>- Grammar rules:    2,048 bytes
</span></span><span class=line><span class=cl>- Player inputs:    36,000 bytes
</span></span><span class=line><span class=cl>- Game state:       16 bytes
</span></span><span class=line><span class=cl>- Total compressed: 38,064 bytes (37.2 KB)
</span></span><span class=line><span class=cl>Compression ratio:  476,671.45x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>To store a 5-minute Pong game:
</span></span><span class=line><span class=cl>1. Conservative Approach (Just Positions)
</span></span><span class=line><span class=cl>   - Raw data: 1,828.1 KB
</span></span><span class=line><span class=cl>   - Compressed: 37.2 KB
</span></span><span class=line><span class=cl>   - Ratio: 49.18x better
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>2. Full Visual Approach (Every Pixel)&#34;)
</span></span><span class=line><span class=cl>   - Raw data: 17,304.7 MB
</span></span><span class=line><span class=cl>   - Compressed: 37.2 KB
</span></span><span class=line><span class=cl>   - Ratio: 476,671.45x better
</span></span></code></pre></td></tr></table></div></div><p>This is remarkable in two ways:</p><ol><li><p><strong>Conservative Estimate</strong> (Just storing positions):</p><ul><li>Raw data: ~1.8 MB</li><li>Compressed: ~37 KB</li><li>Nearly 50x compression just for the game state!</li></ul></li><li><p><strong>Full Visual Data</strong> (Every pixel of every frame):</p><ul><li>Raw data: ~17.3 GB</li><li>Compressed: ~37 KB</li><li>Almost 500,000x compression!</li></ul></li></ol><p>Even our conservative estimate shows impressive compression because we&rsquo;re capturing the underlying game logic. But when we consider that this same grammar can generate the complete visual output, the compression becomes staggering. We achieve this because:</p><ol><li>The rules of the game (our grammar) - about 2KB</li><li>The player inputs - about 35KB</li><li>The game state - just 16 bytes</li></ol><p>The grammar captures both the physics engine and the rendering logic in just 8 rules! This massive compression ratio illustrates a profound point: when we truly understand a system, we don&rsquo;t need to store its behavior - we can store its rules and regenerate any behavior we want. This is exactly how human intelligence works: we don&rsquo;t memorize every position or pixel of every object we&rsquo;ve ever seen moving - we learn the laws of physics and can use them to predict and understand any motion.</p><a href=#the-connection-to-intelligence><h2 id=the-connection-to-intelligence><span class=hanchor arialabel=Anchor># </span>The Connection to Intelligence</h2></a><p>The relationship between compression and intelligence becomes clear when we look at our progression from simple sequences to complex systems. In each case, better compression came from better understanding of the underlying pattern:</p><ol><li>For Fibonacci, understanding the recursive relationship led to 189.21x compression</li><li>For language, recognizing sentence structure led to 22.93x compression (limited by English&rsquo;s context sensitivity)</li><li>For Sanskrit, Panini&rsquo;s grammar achieved remarkable compression of an entire language with just ~4,000 rules</li><li>For Pong, applying Panini&rsquo;s principles to game physics led to 476,671.45x compression</li></ol><p>This progression - from numbers to language to video games - shows how the same fundamental principles of finding minimal generative descriptions apply across domains. This is why compression can be seen as a measure of intelligence: the better we understand a system, the more efficiently we can describe it.</p><p>In machine learning terms, this is closely related to the concept of &ldquo;minimum description length&rdquo; (MDL) principle, which states that the best model for a dataset is the one that minimizes:</p><ol><li>The size of the model (our grammar rules)</li><li>The size of the data when encoded using the model (our inputs)</li></ol><p>This principle was later formalized by Ray Solomonoff in his theory of universal inductive inference. Solomonoff showed that the best prediction for future data comes from the shortest computer program that can generate the observed data. In other words, finding the most compressed representation of data (like Panini&rsquo;s grammar rules) isn&rsquo;t just an efficiency trick - it&rsquo;s mathematically optimal for prediction and understanding.</p><p>The connection to Solomonoff induction helps explain why Panini&rsquo;s grammar has remained useful for over two millennia: by finding the shortest possible rule set that could generate Sanskrit, he wasn&rsquo;t just being clever with compression - he was discovering the true underlying structure of the language. This is exactly what Solomonoff&rsquo;s theory predicts: the shortest description that works is likely to be the correct one.</p><p>This is exactly what we&rsquo;ve demonstrated with our code examples above and what Panini achieved with Sanskrit. His work isn&rsquo;t just limited to modelling the spoken linguistic reality of the time - but was about discovering a universal principle of intelligence that holds the key to building thinking machines of the future.</p><a href=#why-this-matters><h2 id=why-this-matters><span class=hanchor arialabel=Anchor># </span>Why This Matters</h2></a><p>This connection between compression and understanding has profound implications:</p><ol><li><strong>Learning</strong> is essentially finding better grammars for observed data</li><li><strong>Intelligence</strong> can be measured by ability to find compact descriptions in the fewest observations (e.g. by looking at the least number of Fibonacci numbers)</li><li><strong>Understanding</strong> means finding the true generative process</li></ol><p>When a child learns physics, they&rsquo;re not memorizing the position of every object they&rsquo;ve seen - they&rsquo;re learning the grammar of motion. When we understand language, we don&rsquo;t memorize every possible sentence - we learn the rules that generate valid ones. When Panini created his grammar, he wasn&rsquo;t just documenting Sanskrit - he was discovering a fundamental approach to understanding that we can apply to everything from ancient languages to modern video games.</p><p>This is why generative grammars are so powerful: they don&rsquo;t just compress data, they capture the underlying processes that created that data. Whether it&rsquo;s a sequence of numbers, a set of sentences, or a video game, the principle remains the same: understanding the rules of generation is the key to both compression and comprehension.</p><blockquote><p>&ldquo;Riemann invented his geometries before Einstein had a use for them; the physics of our universe is not that complicated in an absolute sense. A Bayesian superintelligence, hooked up to a webcam, would invent General Relativity as a hypothesis‚Äîperhaps not the dominant hypothesis, compared to Newtonian mechanics, but still a hypothesis under direct consideration‚Äîby the time it had seen the third frame of a falling apple. It might guess it from the first frame, if it saw the statics of a bent blade of grass.&rdquo; - E. Yudkowsky</p></blockquote><a href=#references><h2 id=references><span class=hanchor arialabel=Anchor># </span>References</h2></a><p>[1]
<a href="https://www.youtube.com/watch?v=dO4TPJkeaaU" rel=noopener>Youtube video</a>, Compression for AGI, Jack Rae, Stanford MLSys, ex-OpenAI, 2023</p><p>[2]
<a href="https://www.youtube.com/playlist?list=PLsAPTmdVuspykLNnjs1_zQKRMqRRfDr2R" rel=noopener>Youtube Playlist</a>, PƒÅ·πáini Lecture Series, Dr. Saroja Bhate, Bangalore International Center, 2023</p><p>[3] The <em>A·π£·π≠ƒÅdhyƒÅyƒ´</em> achieves a remarkable compression ratio of at least 5000:1, condensing the rules that can generate over 10,000 hours of attested Sanskrit literature (including the ~20,000 verses of the four Vedas, along with the 100,000 verses of the Mahabharata, 24,000 verses of the Ramayana, 400,000 verses of the Puranas, and hundreds of thousands of verses across texts, philosophical shastras, and classical poetry) into just 2 hours of precisely formulated rules.</p><p>[4] PƒÅ·πáini: Catching the Ocean in a Cow&rsquo;s Hoofprint, Vikram Chandra, 2019
<a href=https://blog.granthika.co/panini/ rel=noopener>blog.granthika.co/panini/</a></p></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://sibeshkar.github.io/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Sibesh Kar using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, ¬© 2025</p><ul><li><a href=https://sibeshkar.github.io/>Home</a></li><li><a href=https://twitter.com/sibeshkar>Twitter</a></li></ul></footer></div></div></body></html>